"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[67556],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},56268:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={},i="Lifecycle and Identity",s={unversionedId:"templates/structural_identity",id:"templates/structural_identity",title:"Lifecycle and Identity",description:"Evolve's template system works on a concept called Structural Identity. This means that the compiler",source:"@site/docs/templates/structural_identity.md",sourceDirName:"templates",slug:"/templates/structural_identity",permalink:"/EvolveUIDocs/docs/templates/structural_identity",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Modules",permalink:"/EvolveUIDocs/docs/templates/modules"},next:{title:"Template Reflection",permalink:"/EvolveUIDocs/docs/templates/template_reflection"}},l={},c=[{value:"Asynchronous Lifecycle",id:"asynchronous-lifecycle",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lifecycle-and-identity"},"Lifecycle and Identity"),(0,r.kt)("p",null,"Evolve's template system works on a concept called ",(0,r.kt)("inlineCode",{parentName:"p"},"Structural Identity"),". This means that the compiler\nfigures out which 'scope' an element belongs to and ties that element's lifecycle to the scope. A scope is\nbasically just a sequential list of statements inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," block. "),(0,r.kt)("p",null,"There are two types of ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," in Evolve, a ",(0,r.kt)("inlineCode",{parentName:"p"},"uicontext")," applies to statements inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," block and the\n",(0,r.kt)("inlineCode",{parentName:"p"},"code")," context applies everywhere else, including expressions. The ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," contexts works identically to C# and as\nsuch there is no Evolve magic happening under the hood, where the ",(0,r.kt)("inlineCode",{parentName:"p"},"uicontext")," applies lots of magic and allows the\nuse of ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"enable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"create"),", and other Evolve statement constructs. "),(0,r.kt)("p",null,"Scopes are created whenever we use a new piece of control flow, so ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"repeat"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"slot"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," all\ncreate new scopes. All elements declared in that scope are bound to its lifecycle, so if the scope is disabled or\ndestroyed, so are the elements inside of it. "),(0,r.kt)("p",null,"This means we only create elements when we enter a scope for the first time, and we disable or destroy elements\nwhen the scope is no longer in use. Every frame as your templates execute the system figures out if the control flow\nbeing run was also run last frame or not and decides if it needs to create the elements within this scope or if\nit should use the same instances from last frame. One of the great things about this system is that you can declare\n",(0,r.kt)("inlineCode",{parentName:"p"},"state")," variables anywhere inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"uicontext")," scope, and they will retain their values across frames."),(0,r.kt)("p",null,"Disabling & destruction happen async after the frame finishes, so if you have handlers registered for those\nthey will fire at the start of the NEXT frame, before anything else happens."),(0,r.kt)("p",null,"Here is how a frame is built for each template in your game."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Was this the first time this scope was entered?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,r.kt)("inlineCode",{parentName:"li"},"created")," hooks that are defined on the elements"))),(0,r.kt)("li",{parentName:"ul"},"Was this created this frame or previously disabled?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,r.kt)("inlineCode",{parentName:"li"},"enabled")," hooks"))),(0,r.kt)("li",{parentName:"ul"},"Set all the per-frame 'bindings' for the currently executing element. This includes:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"parameters"),(0,r.kt)("li",{parentName:"ul"},"non constant styles"),(0,r.kt)("li",{parentName:"ul"},"non constant attributes"))),(0,r.kt)("li",{parentName:"ul"},"invoke any before early input hooks"),(0,r.kt)("li",{parentName:"ul"},"process input"),(0,r.kt)("li",{parentName:"ul"},"invoke any after early input hooks"),(0,r.kt)("li",{parentName:"ul"},"invoke any update hooks"),(0,r.kt)("li",{parentName:"ul"},"invoke any after update input hooks"),(0,r.kt)("li",{parentName:"ul"},"recursively visit all the children of this template"),(0,r.kt)("li",{parentName:"ul"},"invoke any late input hooks"),(0,r.kt)("li",{parentName:"ul"},"invoke any finish hooks")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'template Example(required bool showGroup1) render {\n    if(showGroup1) {\n        // a new scope is created for the true case \n        // the two text elements below are bound to this scope\n        // if this branch does not execute in a given frame, \n        // all elements that are descendents of this scope will be\n        // disabled (or destroyed if the scope is marked with :destructive)\n        Text("Element 1");\n        Text("Element 2");\n        \n        Action xyz = () => {\n            // everything in here is C#, so there are not scopes and you cannot use \n            // Evolve constructs like `state` or `enable` or `repeat` \n        };\n        \n        // A \'run\' statements lets you run arbitrary C# code at this exact point in time \n        run {\n            // this is also a C# context \n        }\n        \n        // both sides of this if statement create a new scope. Which ever branch of this \n        // if statement is NOT entered in a given frame, those elements will be disabled\n        // (or destroyed if the :destructive specifier is used) \n        if (someOtherValue) {\n            Text("More elements here");\n        }\n        else {\n            Text("More elements here");\n        }\n    }\n    else {\n        // a new scope is created for the else case \n        // Element 3 is a member of this scope.\n        Text("Element 3");\n    }\n}\n')),(0,r.kt)("h3",{id:"asynchronous-lifecycle"},"Asynchronous Lifecycle"),(0,r.kt)("p",null,"There are two classes of events which are not executed as your code runs each frame: ",(0,r.kt)("inlineCode",{parentName:"p"},"disable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"destroy"),"."),(0,r.kt)("p",null,"For performance reasons we only run these handlers at the start of the next frame. It is illegal / undefined behavior\nif you have a disable/destroy handler that uses a closure to close over any fields / state in a template. Generally,\nyou should not have to worry about this because the system makes it very hard to do, but in case you are tempted to\ntrick the system into doing something crazy: you've been warned!"))}u.isMDXComponent=!0}}]);