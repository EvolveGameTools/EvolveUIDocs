"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[501],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return p}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),m=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=m(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(t),p=a,g=d["".concat(l,".").concat(p)]||d[p]||u[p]||i;return t?r.createElement(g,o(o({ref:n},c),{},{components:t})):r.createElement(g,o({ref:n},c))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},2111:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return m},toc:function(){return u}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],s={},l=void 0,m={unversionedId:"templates/style_syntax",id:"templates/style_syntax",title:"style_syntax",description:"Style Syntax Overview",source:"@site/docs/templates/style_syntax.mdx",sourceDirName:"templates",slug:"/templates/style_syntax",permalink:"/EvolveUIDocs/docs/templates/style_syntax",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"grid_layout_docs",permalink:"/EvolveUIDocs/docs/templates/grid_layout_docs"},next:{title:"Template Syntax",permalink:"/EvolveUIDocs/docs/templates/template_syntax"}},c={},u=[],d={toc:u};function p(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Style Syntax Overview"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'\nstyle <TagName> { ... }\n\n\nstyle xyz {\n    enter/exit can be placed on any block\n    \n    targets are animation/sound/ maybe others? particles? log? emit event?\n\n    enter play animation name;\n    exit play animation name;\n    verbs are play, pause, loop, stop, reset\n}\n\nmixin some-mixin(params) {\n        \n}\n\nstyle withVariables {\n\n    BackgroundColor = var(primary, red);\n\n    [attr:whatever] {\n        set primary = @constColor;\n        set dots.are.valid = green;\n    }\n    \n}\ntexturing --\n    // gradients use only BackgroundImageScaleX but otherwise can accept texture transforms\n    BackgroundImage = linear-gradient("gradientName");\n    BackgroundImage = radial-gradient("gradientName");\n    BackgroundImage = conic-gradient("gradientName");\n    BackgroundImage = elliptical-gradient("gradientName");\n    BackgroundImage = "texture name";\n    \n    Mask = "texture name";\n    Mask = soft-mask("texture name");\n    Mask = soft-mask-inverse("texture name");\n    Mask = hard-mask("texture name");\n    Mask = hard-mask-inverse("texture name");\n\n    MaskThreshold = 0.5; // controls alpha levels to be masked\n\nstyle xyz {\n\n    [init] {\n        // this is valid for exactly 1 frame and only when element is first enabled\n        // useful for transitioning into place via reveals\n        // ie PreferredSize = 0; w/ transition to actual size \n    }\n\n   [focus:descendent] { }\n   [focus:child] { }\n   [focus:parent] { }\n   [focus:ancestor] { }\n   [when:condition] { }\n   [unless:condition] { }\n \n   [when:ancestor attr:key] {}  \n   [when:ancestor attr:key = "SomeValue"] {}\n   \n   [when:parent attr:key] {}\n   [when:parent attr:key = "SomeValue"] {}\n   \n   [when:tag(TagName)] \n   [when:tag(ModuleName::TagName)] \n     \n   [when:root-tag(TagName)] \n   [when:root-tag(ModuleName::TagName)]\n   \n   [when:parent-tag(TagName)]\n   [when:parent-tag(ModuleName::TagName)]\n \n   [when:ancestor-tag(TagName)]\n   [when:ancestor-tag(ModuleName::TagName)]\n   \n   [when:child-with-tag(TagName)]\n   [when:child-with-tag(ModuleName::TagName)]\n   \n   [when:descendent-with-tag(TagName)]\n   [when:descendent-with-tag(ModuleName::TagName)]\n   \n   [when:first-with-tag(TagName)]\n   [when:first-with-tag(ModuleName::TagName)]\n   \n   [when:last-with-tag(TagName)]\n   [when:last-with-tag(ModuleName::TagName)]\n   \n   [when:only-with-tag(TagName)]\n   [when:only-with-tag(ModuleName::TagName)]\n   \n}\n\n// any property that is a string value in a style file is mapped to a value in the compilation with the same name \n\nanimation pulse {\n    \n    Iterations = 2;\n    Duration = 1000ms;\n    Delay = 100ms;\n    ForwardStartDelay = 0;\n    ReverseStartDelay = 0;\n    LoopType = PingPong | Constant;\n    Direction = forward;\n    Easing = bezier(0, 1, 1, 0) | Easing Enum  Value\n    \n    AssignProperties = BeforeStart | AfterCompleted | WhileRunning | WhileDelaying;\n\n    0% {\n        PreferredWidth = current;\n    }\n    50% {\n        PreferredWidth = 1cnt;\n    }\n    75% {\n        PreferredWidth = 0.5cnt;\n    }\n    100% {\n        PreferredWidth = 2cnt;\n    }\n    \n}\n\nstyle style1 {\n    transition spring(gentle) 200 = BackgroundColor, PreferredWidth;\n    transition spring(wobbly) 200 = PreferredHeight;\n    \n    mixin (something-no-params);\n    mixin (style2); // can also mixin styles but they can\'t take arguments in that case\n    \n    mixin (something-with-params) {\n        color = orange;\n    }\n    \n}\n\nstyle style2 { .. }\n\nmixin something-no-params() {\n    BackgroundColor = red;\n}\n\nmixin something-with-params(%color = magenta) {\n    BackgroundColor = %{color};\n}\n\nconst s = 1, 2, 3, 4;\n// delay is an optional final parameter for all elements\ntransition *easingfn* 1000ms 500ms? = PreferredWidth; \ntransition QuarticEaseIn 1000ms 500ms = PreferredWidth;\ntransition spring(default | gentle | stiff | wobbly | slow | superslow) = PreferredWidth;\ntransition spring(@s) = PreferredWidth;\ntransition spring(120, 10) = PreferredWidth; // stiffness, damping\ntransition spring(120, 10, 1) = PreferredWidth; // stiffness, damping, mass\ntransition spring(120, 10, 2, 0.1) = PreferredWidth; // stiffness, damping, mass, precision\ntransition bezier(1, 2, 3, 4) duration delay = PreferredWidth;\n')))}p.isMDXComponent=!0}}]);