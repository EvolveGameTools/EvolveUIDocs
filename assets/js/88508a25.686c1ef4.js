"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[92294],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=p(n),c=i,m=h["".concat(s,".").concat(c)]||h[c]||u[c]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},10688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={},o="Create and Animate the Quest Filter",l={unversionedId:"Tutorials/QuestLog/createNavigation",id:"Tutorials/QuestLog/createNavigation",title:"Create and Animate the Quest Filter",description:"This document needs an UPGRADE",source:"@site/docs/Tutorials/QuestLog/createNavigation.mdx",sourceDirName:"Tutorials/QuestLog",slug:"/Tutorials/QuestLog/createNavigation",permalink:"/EvolveUIDocs/docs/Tutorials/QuestLog/createNavigation",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorials",previous:{title:"Create the Main Screen",permalink:"/EvolveUIDocs/docs/Tutorials/QuestLog/createMainScreen"},next:{title:"Populate the Quest List",permalink:"/EvolveUIDocs/docs/Tutorials/QuestLog/populateQuestList"}},s={},p=[{value:"Update AppRoot",id:"update-approot",level:2},{value:"Add the Elements",id:"add-the-elements",level:2},{value:"Register Player Interactions",id:"register-player-interactions",level:2}],d={toc:p};function h(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"create-and-animate-the-quest-filter"},"Create and Animate the Quest Filter"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This document needs an UPGRADE")),(0,i.kt)("p",null,"The player will be able to filter the quests based on those that are active or completed. The filter will be triggered by a click event that is hooked up to two text elements. There will be a simple bar that animates as it transitions from one element to the other. Here's what it'll look like when you are done:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"no animation",src:n(61689).Z,width:"1323",height:"744"})),(0,i.kt)("p",null,"Before jumping in you will need new ",(0,i.kt)("strong",{parentName:"p"},"UI")," and ",(0,i.kt)("strong",{parentName:"p"},"Style")," assets to work out of. Create them via a subdirectory under ",(0,i.kt)("strong",{parentName:"p"},"UserInterface")," and name them both ",(0,i.kt)("strong",{parentName:"p"},"QuestList"),"."),(0,i.kt)("h2",{id:"update-approot"},"Update AppRoot"),(0,i.kt)("p",null,"It is possible to have templates call other templates. This is very helpful for creating modular code that is easier to maintain. Lets have you take care of that part of the setup before jumping into building out QuestList - that way you can see your progress in real time."),(0,i.kt)("p",null,"Open ",(0,i.kt)("inlineCode",{parentName:"p"},"AppRoot.ui")," and add the following code to the end of the Template:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'template AppRoot : AppRoot render {\n\n   Div(style = [@header-row]) {\n       Div(style = [@gradient-line]);\n       Title("Quests"); \n       Div(style = [@gradient-line]);\n   }\n\n   //highlight-start\n   Div(style = [@master-detail-container]) {\n        QuestList();\n   }\n    //highlight-end\n}\n')),(0,i.kt)("p",null,"Add the following style to ",(0,i.kt)("inlineCode",{parentName:"p"},"AppRoot.style"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-css"},"style master-detail-container {\n    LayoutType = Horizontal;\n    SpaceBetweenHorizontal = 50px;\n    PreferredSize = 1s;\n}\n")),(0,i.kt)("p",null,"Everything here is straight forward. As you can see, the only new concept is that you supply the name of the template to reference it."),(0,i.kt)("h2",{id:"add-the-elements"},"Add the Elements"),(0,i.kt)("p",null,"The first thing you'll do is setup the base elements that the player will interact with. Open ",(0,i.kt)("inlineCode",{parentName:"p"},"QuestList.ui")," and add the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using QuestLog;\nusing System;\nusing System.Collections.Generic;\n\ntemplate QuestList {\n    render {\n        Group(style = [@quest-list-header]) {\n           Text_H2("Active", attr:uppercase);\n           Text_H2("Completed", attr:uppercase);\n        }\n        \n        Div(style = [@accent]);\n    }    \n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Group")," is another way to organize elements, like a Div. ",(0,i.kt)("inlineCode",{parentName:"p"},"Text_H2")," is the typography element that you created earlier. The uppercase attribute ensures that the text is displayed as such, thereby removing the dependency on the code to be correct."),(0,i.kt)("p",null,"Next, add the following styles to ",(0,i.kt)("inlineCode",{parentName:"p"},"QuestList.style"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-css"},"const color_LightWhite = #6D6C72;\n\nstyle quest-list-header {\n    LayoutType = Horizontal;\n    SpaceBetweenHorizontal = 32px;\n    PreferredWidth = 496px;\n    PaddingLeft = 32px;\n    BorderBottom = 1px;\n    BorderColor = @color_LightWhite;\n    PaddingBottom = 8px;\n    MarginBottom = 12px;\n}\n\nstyle accent {\n\n    LayoutBehavior = Ignored;\n    PreferredSize = 90px 4px;\n    BackgroundColor = white;\n    AlignmentOriginX = -0.5w;\n    AlignmentOffsetX = 70px;\n    AlignmentOffsetY = 35px;\n    AlignmentTarget = Parent;\n    CornerRadius = 50%;\n    ShadowColor = white;\n    ShadowBlur = 15;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"accent")," is introducing a few new style properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LayoutBehavior")," specifies whether the element should participate in the parent's layout phase. In this case, accent is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"Ignored"),", which means that it will not contribute to the parent size. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AlignmentOrigin"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"AlignmentOffset")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"AlignmentTarget")," are properties that adjust how the element aligns in relation to its parent. For example, because ",(0,i.kt)("inlineCode",{parentName:"li"},"AlignmentOriginX")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"-0.5w"),", the element will adjust the X starting position to be negative half the width of the parent. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CornerRadius")," changes the element to have rounded corners by the specified amount."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ShadowColor")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"ShadowBlur")," can be used to add a shadow effect and are responsible for the nice glow that the bar has.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Try changing the values of the elements above to see how they impact the visual look.")),(0,i.kt)("p",null,"Push play to see how your new elements are drawn onto the UI. There's no interactivity yet though! You'll do that next."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"no animation",src:n(66399).Z,width:"1032",height:"240"})),(0,i.kt)("h2",{id:"register-player-interactions"},"Register Player Interactions"),(0,i.kt)("p",null,"Two things need to happen when the player clicks on of the filters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The bottom highlight needs to move to the new active state"),(0,i.kt)("li",{parentName:"ul"},"The list of quests needs to filter based on their status")),(0,i.kt)("p",null,"There also needs to be a check to make sure that nothing happens when the player clicks on the filter that is already enabled. "),(0,i.kt)("p",null,"In this section you will focus just on animating the bottom highlight. Add the following code to the top of ",(0,i.kt)("inlineCode",{parentName:"p"},"QuestList.UI"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"template QuestList {\n    //highlight-start\n    state QuestStatus status = QuestStatus.Active;\n    \n    state float animTargetX = 0;\n    state float animTargetWidth = 0;\n    \n    bool shouldStartAnimation = false;       \n    \n    state Action<UIElement, QuestStatus> QuestFilter_OnClick = (el, newStatus) => {\n       if(status == newStatus) {\n           return;\n       }\n       \n       status = newStatus;\n       \n       animTargetWidth = el.GetLayoutSize().width;\n       animTargetX = el.GetLayoutLocalPosition().x + animTargetWidth * 0.5f;\n\n       shouldStartAnimation = true;\n       \n    };\n    //highlight-end\n    //original code after this point\n    render { \n       ...\n    }\n}\n\n")),(0,i.kt)("p",null,"The code above is defining and setting four ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," variables. State variables are a special kind of variable that persist across frames like regular C# variables. However, unlike regular variables, the value assignment runs just once when the template is first instantiated. Here is a deeper look at each variable:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"status")," tracks whichever filter is currently active and is also set to ",(0,i.kt)("inlineCode",{parentName:"li"},"QuestStatus.Active")," by default."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"animTargetX")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"animTargetWidth")," set the target x position and width of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Div/Accent")," element that you created earlier. These values will be set again and used with the animation runs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"shouldStartAnimation")," represents whether code should run to move the ",(0,i.kt)("inlineCode",{parentName:"li"},"Div/Accent")," element to a new filter. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"QuestFilter_OnClick")," is an ",(0,i.kt)("inlineCode",{parentName:"li"},"Action")," that will run each time the player clicks on a filter. The first thing it'll do is confirm that the player clicked on a new filter and will abort if they did not. The status is updated and animation values are set if the check passes.")),(0,i.kt)("p",null,"It is now time to hook up the click event. Update the two ",(0,i.kt)("inlineCode",{parentName:"p"},"Text_H2")," elements so that they include a ",(0,i.kt)("inlineCode",{parentName:"p"},"mouse:click")," event: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'Group(style = [@quest-list-header]) {\n   Text_H2("Active", attr:uppercase,\n    //highlight-start\n        mouse:click = QuestFilter_OnClick($this, QuestStatus.Active));\n    //highlight-end\n\n   Text_H2("Completed", attr:uppercase,\n    //highlight-start\n      mouse:click = QuestFilter_OnClick($this, QuestStatus.Completed));\n  //highlight-end\n  });\n')),(0,i.kt)("p",null,"Any element can register a callback. You just need to provide a prefix (i.e ",(0,i.kt)("inlineCode",{parentName:"p"},"mouse"),"), the event type (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"click"),"), and assign it code to run. The Active and Completed filters are both registered to handle ",(0,i.kt)("inlineCode",{parentName:"p"},"mouse:click")," events and pointed towards ",(0,i.kt)("inlineCode",{parentName:"p"},"QuestFilter_OnClick"),". "),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"There are many different types of events that you can hook into that cover mouse, keyboard, drag & drop, and touch events. You can read more ",(0,i.kt)("a",{parentName:"p",href:"/docs/templates/top_level_declarations/members/input_handlers"},"here"),".")),(0,i.kt)("p",null,"If you were to click on one of the buttons nothing would happen. That's because the actual animation logic is missing. Update the ",(0,i.kt)("inlineCode",{parentName:"p"},"Div/Accent")," element at the bottom of your code with the following ",(0,i.kt)("inlineCode",{parentName:"p"},"on:update")," event:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Div(style = [@accent], before:update => {\n    if (shouldStartAnimation) {\n        $this.style.SetAlignmentOffsetX(animTargetX);\n        $this.style.SetPreferredWidth(animTargetWidth);\n    }\n});\n")),(0,i.kt)("p",null,"Elements also have several ",(0,i.kt)("a",{parentName:"p",href:"/docs/templates/top_level_declarations/members/lifecycle"},"lifecycle hooks")," that you can use. In this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"on:update")," hook is used to check whether the element needs to be animated, and if so, sets a new ",(0,i.kt)("inlineCode",{parentName:"p"},"AlignmentOffsetX")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PreferredWidth")," values based on the animation state variables defined and set earlier. "),(0,i.kt)("p",null,"Run or reload the project in Unity and try clicking on one of the filters."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"no animation",src:n(18892).Z,width:"611",height:"171"})),(0,i.kt)("p",null," Unfortunately, it's not smoothly animating just yet. This is because there's one style property that is missing from ",(0,i.kt)("inlineCode",{parentName:"p"},"Accent"),". Open ",(0,i.kt)("inlineCode",{parentName:"p"},"QuestList.style")," and update the accent style to include the following property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-css"},"style accent {\n    /* Other styles above */\n    transition CubicEaseIn 200ms = AlignmentOffsetX, PreferredWidth;\n}\n")),(0,i.kt)("p",null,"Transitions are easy to implement animations that observe style properties. When a property value is changed, the system will smoothly transition from the old value to the new one. Transitions are built on top of the animation system, which uses a ",(0,i.kt)("a",{parentName:"p",href:"/docs/templates/top_level_declarations/members/instance_style"},"generic interpolator")," that you can extend. In the property above, the standard ",(0,i.kt)("inlineCode",{parentName:"p"},"CubicEaseIn")," interpolator is used. The duration is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"200ms")," and the properties that the transition will monitor for are ",(0,i.kt)("inlineCode",{parentName:"p"},"AlignmentOffsetX")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PreferredWidth"),"."),(0,i.kt)("p",null,"Run or reload the project again and you should now see it smoothly animating."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"no animation",src:n(77413).Z,width:"611",height:"171"})))}h.isMDXComponent=!0},61689:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/createAnimateNavEndState-e713e7d07089af1d173e10089cebcc53.gif"},66399:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/nav_static_anim-1143cf6185c1b83a00ee283b816ed4fc.png"},18892:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/navigation_no_animation-dcedce60d7974cbb7861b990697bc098.gif"},77413:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/navigation_with_animation-faf54c7f613d1ef14abd8a1c91cb2590.gif"}}]);