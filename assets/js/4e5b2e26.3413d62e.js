"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[976],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),d=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=d(e.components);return i.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=d(t),m=a,p=h["".concat(s,".").concat(m)]||h[m]||c[m]||o;return t?i.createElement(p,r(r({ref:n},u),{},{components:t})):i.createElement(p,r({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},9877:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return c}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),r=["components"],l={},s="Template Syntax",d={unversionedId:"templates/template_syntax",id:"templates/template_syntax",title:"Template Syntax",description:"EvolveUI has a very sophisticated template engine that takes in .ui",source:"@site/docs/templates/template_syntax.mdx",sourceDirName:"templates",slug:"/templates/template_syntax",permalink:"/EvolveUIDocs/docs/templates/template_syntax",tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Style Syntax",permalink:"/EvolveUIDocs/docs/templates/style_syntax"}},u={},c=[{value:"Exploring Template Syntax",id:"exploring-template-syntax",level:2},{value:"Data Binding",id:"data-binding",level:2},{value:"Referencing C# Namespaces",id:"referencing-c-namespaces",level:2},{value:"Referencing other Evolve modules",id:"referencing-other-evolve-modules",level:2},{value:"Defining a Backing Class for templates",id:"defining-a-backing-class-for-templates",level:2},{value:"Defining templates",id:"defining-templates",level:2},{value:"Control flow",id:"control-flow",level:2},{value:"Life cycle sections",id:"life-cycle-sections",level:2},{value:"Slots",id:"slots",level:2},{value:"Portals",id:"portals",level:2},{value:"Decorators",id:"decorators",level:2},{value:"Containers and Typography",id:"containers-and-typography",level:2},{value:"String Interpolation",id:"string-interpolation",level:2},{value:"Markers",id:"markers",level:2},{value:"Lifecycle Hooks",id:"lifecycle-hooks",level:2},{value:"Expression Extrusion",id:"expression-extrusion",level:2},{value:"Modules",id:"modules",level:2}],h={toc:c};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"template-syntax"},"Template Syntax"),(0,o.kt)("p",null,"EvolveUI has a very sophisticated template engine that takes in ",(0,o.kt)("inlineCode",{parentName:"p"},".ui"),"\ntemplate syntax and converts it to IL code that is executed.\nThere are two ways this can happen, either at application start up time\nor as a build step. When running in dynamic mode, all the templates are\nparsed and MSIL is generated for them (assuming there weren't any\ncompilation errors)"),(0,o.kt)("p",null,"When precompiling we generate real C# code. This means we can fully support any AOT platforms and even run in Unity's il2cpp mode."),(0,o.kt)("p",null,"Performance between these two modes should be relatively similar,\nthough precompiling runs a bit faster. Typically\nin development you would use dynamic mode because it allows you to\nhot-reload the entire UI when you change a template or style file. The\nexception to this rule is debugging. If you run into an issue with your\ntemplates that you'd like to debug, it may be easier to generate the\ncode and then set a breakpoint in the generated code."),(0,o.kt)("p",null,"Ok, on to the fun stuff!"),(0,o.kt)("p",null,"Totally random ordering...will improve this later"),(0,o.kt)("h2",{id:"exploring-template-syntax"},"Exploring Template Syntax"),(0,o.kt)("p",null,"A template is defined in a ",(0,o.kt)("inlineCode",{parentName:"p"},".ui")," file and describes the structure of a UI.\nEvolveUI is entirely template based and does not support\nmanual hierarchy manipulation from code. This is completely by design\nand while it may feel limiting when you first read this, it is actually\na huge benefit because of another awesome feature: Data Binding."),(0,o.kt)("h2",{id:"data-binding"},"Data Binding"),(0,o.kt)("p",null,"Any field, property, method, event, or value you use in data binding\nexpressions will need to be public. The reason for this is that when the\ncode is pre-compiled to C#, it will not compile if you use non\naccessible values."),(0,o.kt)("p",null,"In general you want to keep the data flow of\nyour UI in a top down direction. There are use cases for two way binding\non some elements like ",(0,o.kt)("inlineCode",{parentName:"p"},"TextInput")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Dropdown")," but in general you should\nstrive to pass data down to children and not up to parents."),(0,o.kt)("h2",{id:"referencing-c-namespaces"},"Referencing C# Namespaces"),(0,o.kt)("p",null,"Evolve can reference namespaces with at ",(0,o.kt)("inlineCode",{parentName:"p"},"using")," statement that functions identically to C#'s ",(0,o.kt)("inlineCode",{parentName:"p"},"using")," statement"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"using System.Collectsion.Generic;\n\ntemplate UsingNameSpaceExample {\n\n    // without the using statement, the compiler would not be able to find the List type\n    state List<string> strings = new List<strings>();\n\n    Text(strings.Count);\n\n}\n")),(0,o.kt)("h2",{id:"referencing-other-evolve-modules"},"Referencing other Evolve modules"),(0,o.kt)("p",null,"Imports work on a module level, once imported, all styles, elements, templates, and functions are available via the imported alias\nusing the scope specifier operator ::.\n",(0,o.kt)("inlineCode",{parentName:"p"},"MyModule::SomeElement(style = [@MyModule::some-style])"),".\nYou can also import everything in a module and expose it implicitly (without needing the scope operator)\nbut if any naming conflicts occur, an error will be raised and you will need to use the scope operator in order to disambiguate the names.\nModules that are imported implicitly will still need to provide an alias"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'import "Module1" as Mod1; // import that defines an alias\nimport implicit "Module2" as Mod2; // implicit import with an alias\nimport implicit "Module3"; // no alias\n\ntemplate ImportExample {\n\n    Mod1::SomeElementFromModule1(); // Module1 was NOT imported implicitly so the scope operator IS required. \n\n    SomeElementFromModule2(); // Module2 was imported implicitly so the scope operator isn\'t required \n    Mod2::SomeElementFromModule2(); // Module2 was imported implicitly so the scope operator isn\'t required but \n\n    SomeElementFromModule3(); // Module3 was imported implicitly so the scope operator isn\'t required\n    Module3::SomeElementFromModule3(); // Module3 was imported implicitly so the scope operator isn\'t required\n\n}\n\n')),(0,o.kt)("h2",{id:"defining-a-backing-class-for-templates"},"Defining a Backing Class for templates"),(0,o.kt)("p",null,"Every template requires a backing C# to that must extend ",(0,o.kt)("inlineCode",{parentName:"p"},"UIElement"),". The purpose of this element is to provide data for the template.\nThere are three ways provide this backing class. "),(0,o.kt)("p",null,"The first way is to define your class in C# and then reference it with the ",(0,o.kt)("inlineCode",{parentName:"p"},":")," operator in the template declaration"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// in C#\npublic class ButtonFromCSharp : UIElement {\n    public string title; \n    public string tooltip = "default value can go here optionally"; \n}\n\n// in a .ui file\ntemplate MyButton : ButtonFromCSharp {\n    \n    // title and tooltip are being from ButtonFromCSharp\n    Text(title); \n    Text(tooltip);\n\n}\n\n')),(0,o.kt)("p",null,"The second way to is define your class dynamically using the ",(0,o.kt)("inlineCode",{parentName:"p"},"element")," keyword in a .ui file"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// in a .ui file\n\n// Element nodes are shortcuts for defining a C# class extending UIElement. \n// It can define only fields that are implicitly public.\n// Methods, events, and properties are not allowed\n\nelement ButtonFromUIFile {\n    string title;\n    string tooltip = \"default value goes here optionally\";\n}\n\n// note the use of the 'element' keyword here as well\ntemplate MyElement : element ButtonFromUIFile {\n\n    // title and tooltip are being from ButtonFromUIFile\n\n    Text(title); \n    Text(tooltip);\n\n}\n")),(0,o.kt)("p",null,"The third way is useful for when you don't actually need to reference any data from a backing element class. In this case\nyou can completely omit the backing class and one will be generated for you."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"template MyElementWithAnImplicitBackingClass {\n    // ... contents ...\n}\n\n")),(0,o.kt)("h2",{id:"defining-templates"},"Defining templates"),(0,o.kt)("p",null,"Templates are defined via the ",(0,o.kt)("inlineCode",{parentName:"p"},"template")," keyword and given a tag name. In this example we create a template based on the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Button")," element defined above. It happens to use a tag name ",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleButton")," and is referred to in templates using\n",(0,o.kt)("inlineCode",{parentName:"p"},"ExampleButton()")," and not ",(0,o.kt)("inlineCode",{parentName:"p"},"Button()"),".\nBehind the colon (:) comes the namespace and class path of the backing type. In this case we defined ",(0,o.kt)("inlineCode",{parentName:"p"},"Button")," in the same file\nbut if we wanted to use a C# class instead we would have to refer to it by its namespace. So if you Button type was in\nnamespace ",(0,o.kt)("inlineCode",{parentName:"p"},"Example.Controls"),", the syntax would be ",(0,o.kt)("inlineCode",{parentName:"p"},"template ExampleButton : Example.Controls.Button")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'template ExampleButton : element Button() {\n\n    Text(text);\n    Text(tooltip);\n\n}\n\n// elements defined in this way can be type referenced with the element<> operator\nelement<Button> button;\nbutton.text = "whatever";\n\n// Templates can also accept generic types. The backing class DOES NOT have to also be generic or use the types provided.\n// Templates can also accept binding arguments like other elements.\ntemplate Generic<T, U> : Example.Generic<T, U>(attr:isGeneric = "true", isCool = true, mouse:click = () => Debug.Log("Awesome")) {\n\n    // we can define variables with the var syntax. `var Type variableName = value;`\n    // variables are re-initialized every frame and do not hold their value across frames\n    var T val = value;\n\n    // state fields work just like variables, but they are persisted across frames. The value assignment runs only once, on creation.\n    state U stateVal = value2;\n\n    state bool x = true;\n\n    // the assignment value for variables and state fields can be any C# expression where the resulting type can be coearsed to the declared var/state type\n    var List<string> strings = GetStringList();\n\n    // to differentiate between running code and running templates, we use the `run` keyword\n    run x = false;\n    run SomeCSharpFunction();\n    run SomethingWithOutParam(out x);\n\n    // this can also be a block, then every statement doesn\'t need a `run` command in front of it\n    run {\n        x = false;\n        SomeCSharpFunction();\n        SomethingWithOutParam(out x);\n    }\n\n}\n\n// Elements are invoked like functions.\ntemplate ElementExample : ElementExample() {\n\n    // elements can accept property bindings if they define them in C# (or via `element` template declaration)\n    ElementWithBinding(value = GetValue());\n\n    // Text primitives accept a string as their default argument\n    // Styles are referenced via the @ symbol. If the style is originating from a module import,\n    // the style must be resolved through the imported alias. \n    Text("Implict argument", style = [@text-style]);\n    Text("Implict argument", style = [@importedModule::label-style]);\n    \n    // While text cannot have a child elements, other primitive container elements like `Div` can\n    Div() {\n        Text("Hello");\n    }   \n\n    // container elements do not have to provide children\n    Div();\n\n    // Templates are also invokable in the same way primitive elements are. Some accept children slots,\n    // some do not. If the element does not expose a slot for children, and children are provided, you will get an error at compile time\n    CharacterList(list = characters);\n\n    // This element exposes a slot for children. If the name of the slot is `implicit` then the user of the element\n    // does not use extra syntax for this. If the name is something else you need to use the `override` keyword with the slot name\n    ThingAcceptingChildren() {\n        \n        Text("I\'m a child in the implicit slot");\n\n        override explicit-slot-name {\n            Text("I\'m a child in an explicitly named slot");\n        }\n\n    }\n\n    // Things with internal state can have that state \'extruded\' via square bracket syntax.\n    // If our `ThingWithExtrusions` defines a field or property `color` and `id`, we can access them\n    // in the nested scope of the template like below. If there are naming conflicts in the scope, you \n    // can alias the extruded values with the `as` keyword. \n    ThingWithExtrusions() [color, id as identifier] {\n        ColorPicker(color = color);\n        TextField(value = identifier);// refer to ThingWithExtrusions.id as `identifier` instead.\n    }\n\n}\n\n// Functions are snippets of code that can be re-used. At compile time they may get inlined and have no performance overhead\ntemplate XYZ : XYZ()  {\n\n    // functions can accept as many arguments as you like. These are then available in the defining scope of the function\n    fn CallMe(int v) {\n        Text("The value is: " + v.ToString());\n    }\n\n    // Functions are called with the `invoke` keyword\n    invoke CallMe(0);\n    invoke CallMe(1);\n    invoke CallMe(2);\n\n    // Functions may also be generically typed\n    fn CallMeGeneric<T, U, V>(T value, U uValue) {\n        Text("The T value is: " + value.ToString());\n        Text("The U type is: " +  uValue.ToString());\n        Text("The V type is: " + typeof(V).ToString());\n    }\n\n    // Calling a generic function requires specifying the types explicitly. This may be relaxed in the future. \n    invoke CallMeGeneric<int, string, List<bool>>(5, "hello");\n    invoke CallMeGeneric<float3, string, float4x4>(new float3(1, 1, 1), "hello");\n\n    // functions can be nested within each other, closures are also fully supported so you don\'t need to worry about scoping\n    fn Outer(int outerValue) {\n        \n        Text("FromOuter");\n        \n        var int closuresAreFine = 20;\n\n        fn Inner() {\n            Text("From Inner: "  + closuresAreFine + outerValue);\n        }\n\n        invoke Inner();\n        run closuresAreFine = 40;\n        invoke Inner();\n        run closuresAreFine = 60;\n        invoke Inner();\n    }\n\n    invoke Outer(10);\n\n    // Functions can expose a body block to be invoked later as the function executes with the `invoke default` directive. \n    // The body block is optional.\n    fn FuncWithBody() {\n        Text("Before body");\n        invoke default;\n        Text("After body");\n    }\n\n    // here is how the body is provided\n    invoke FuncWithBody() {\n        Text("I am the body");\n    }\n\n    // another example, the same function can be invoked with as many body variations as you like\n    invoke FuncWithBody() {\n        Text("I am the body");\n        Text("but i am different");\n    }\n\n    // functions can also define values to be extruded by their body slots. \n    // all the extrusion parameters are initialized to default(type) every frame.\n    // note that the extrusion list here DOES NOT GET PUT INTO THE SCOPE\n    // this is only to signify the signature which body slots get invoked with \n    fn FuncWithBodyAndExtrusions(float x, float y) [int invokeCount, string str, float f] {\n        \n        state int invokeCount = 0; // define state for invokeCount. the extruded int invokeCount is NOT usable and so we define our own \n\n        Text("Before body");\n        \n        invoke implicit(invokeCount, "hello", 57f);\n        run invokeCount++;\n\n        Text("After body");\n\n    }\n\n    // here we use the extrusion parameter `invokeCount` and pass it to our body block\n    invoke FuncWithBodyAndExtrusions() [invokeCount] {\n        Text("The function has run " + invokeCount + " times");\n    }\n\n    // functions can also accept named slots \n\n    @AllowMultipleBodyInvocations\n    fn FnWithSlots() [int callId] {\n        // you can invoke the default body as many times as you like, but you must mark the function as AllowMultipleBodyInvocations,\n        // otherwise the subsequent slot invocations will silently do nothing. Note that this has some overhead because the body slot\n        // must be cloned each time it is invoked, where in the default case we do not have this cloning overhead\n        invoke slot implicit(0);\n        invoke slot implicit(1);\n        invoke slot implicit(2);\n        invoke slot implicit(3);\n        invoke slot implicit(4);\n    }\n    \n    // functions can also accept named slots\n    fn FnWithNamedSlots() [int value] {\n        invoke slot thing(0);\n        invoke slot other(1);\n        invoke slot implicit(2);\n\n        // the name of the slot can be an expression too\n        invoke slot[Math.Random() > 5 ? "thing" : "other"];\n\n        // you can also invoke slots that are not provided, these will silently do nothing \n        invoke slot notHere(3);\n\n        invoke slot["not_defined"](4);\n\n    }\n\n    invoke FnWithNamedSlots() [int value] {\n\n        slot thing {\n            Text("Im in slot \'thing\'");\n        }\n        \n        slot other {\n            Text("Im in slot \'other\'");\n        }\n\n        Text("Everything else is in the implicit slot");\n\n    }\n\n    // an example use case for slots might be content transitions with animations\n\n    // function arguments can also be synchronized to reflect their values into the caller,\n    // as long as the input expression is assignable\n    fn DoubleThis(int val) {\n        run val *= 2;\n    }\n    \n    state int x = 10;\n    state int y = 10;\n    invoke DoubleThis(sync: x);\n    invoke DoubleThis(y);\n    run Debug.Log(x); // output => 20\n    run Debug.Log(y); // output => 10 because it didn\'t sync\n}\n')),(0,o.kt)("h2",{id:"control-flow"},"Control flow"),(0,o.kt)("p",null,"Control flow is done similar to C#, we have if/else, switch, and foreach concepts."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'template ControlFlow {\n\n    if(someCondition) {\n        Text("Some condition is true");\n    }\n    else if(!someCondition && somethingElse) {\n        Text("Some condition is false but something else is true");\n    }\n    else {\n        Text("Some condition is false");\n    }\n\n    // switches work on enums or integer-like things (ushort, short, byte, char, etc). There is no fall through, \n    // and the cases must be followed by a set of { }. There is also no break keyword. \n    switch(someIntValueorEnum) {\n        case 0 {\n            \n        }\n\n        case 100 {\n\n        }\n\n        default {\n\n        }\n    }\n\n    // Foreach is like a repeat, it invokes the provided body block multilpe times.\n    // By default the current item is exposed as whatever you name it. The index is available via extrusion\n    foreach(item in list) {\n        Text(item.name)\n    }\n\n    foreach(item in list) [index] {\n        Text(item.name + " is at index " + index);\n    }\n\n    // length is also available\n    foreach(item in list) [index, length] {\n        Text(item.name + " is at index " + index + " out of " + length);\n    }\n\n    // Pagination is also available. (start at item 20, show at most 20)\n    foreach(item in list, start = 10, count = 20) { }\n\n    // Pagination is also available. (start at item 20, show at most 20, every iteration jumps 2 elements)\n    foreach(item in list, start = 10, count = 20, step = 2) { }\n\n    foreach(item in ForeachRange.Times(5)){\n        // loop 5 times\n    }\n    \n    foreach(item in ForeachRange.Inclusive(5, 25)) {\n        // loop with item ranging from 5 to 25\n    }\n\n    foreach(item in ForeachRange.Exclusive(5, 25)) {\n        // loop with item ranging from 5 to 24\n    }\n\n    foreach(item in list, step = 2) {\n        // loop over every 2nd item\n    }\n\n    foreach(item in list, start = 8, end = 12) [index, iteration] {\n        // loop items 8 to 12\n        // index will hold the absolute index\n        // iteration holds the iteration number \n    }\n\n\n    // scope lifecycle can also be controlled. Sometimes you have UI where you know the elements will not be used again for a while\n    // In this case its best to just destroy everything and re-create it when you need it again. In other cases you have elements\n    // you expect to use again shortly and you want to just disable them when the surrounding scope is not entered. \n\n    if(something) {\n        // by default we just disable these elements if the branch is not entered\n        Text("Disable me if something is false");\n    }\n\n    if:destructive(something) {\n        // if we use the `destructive` modifier, we destroy the contents of this scope if the branch is not taken\n        Text("Destroy me if something is false");\n    }\n\n    // All the control flow concepts can be marked as `destructive`\n    if(x) {}\n    else:destructive {\n\n    }\n\n    // all cases are destroyed if not used\n    switch:destructive(thing) {}\n\n    switch(thing) {\n        case:destructive 0 {        }\n        case:destructive 100 {        }\n    }\n\n    foreach:destructive(item in list) {}\n\n}\n')),(0,o.kt)("h2",{id:"life-cycle-sections"},"Life cycle sections"),(0,o.kt)("p",null,"Sections allow arbitrary code to be run on certain lifecycle events for a scope."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'\ntemplate SectionDemo {\n\n    state int enableCount = 0;\n    state int disableCount = 0;\n\n    // Create runs when this scope is first created and never again. \n    create {\n        Debug.Log("Created the template")\n    }\n\n    if(x == 0) {\n      \n        // Enable runs when this scope is entered and was not entered last frame\n        enable {\n            enableCount++;\n            Debug.Log("Enabled " + enableCount + "times");\n        }\n\n        // Disable runs when this scope was entered last frame and was not entered this frame.\n        // Note that some bindings may not have run (because we didnt enter certain scopes this frame)\n        // and data *might* be stale, you will have to architect around this\n        disable {\n            disableCount++;\n            Debug.Log("Disabled " + disableCount + "times"); \n        }\n\n        // Destroy runs when the scope was destroyed\n        destroy {\n            Debug.Log("Destroyed!");\n        }\n\n    }\n\n    // It doesn\'t matter where you put these section blocks, they can go anywhere in the template and a single scope can have multiple blocks. Go nuts!\n\n    switch(x) {\n        case 0 {\n            enable { Debug.Log("Enabled!"); }\n            Text("Element"):\n            enable { Debug.Log("Enabled in a second block"); }\n        }\n    }\n\n    create {\n        Debug.Log("Created the template")\n    }\n}\n\n')),(0,o.kt)("h2",{id:"slots"},"Slots"),(0,o.kt)("p",null,"Slots are ways of exposing pluggable functionality between elements. They are a low overhead way to customize certain elements from the outside"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},' \ntemplate SlotExample : SlotExample() {\n\n    // you define a slot by giving it a name. The only special name is `implicit` which allows the user to \n    // write their template as though they were not overriding a slot.\n\n    // Slot definition can happen in two ways. The first way defines the slot, but doesn\'t actually use it.\n    define slot implicit();\n\n    // slot definitions can optionally provide a default body block. This block is used if the slot is not overridden.\n    define slot implicit()  {\n        Text("Default body for slot");\n    }\n\n    // in order to render a slot, you use the `render keyword`. You can render a single slot as many times as you like, wherever you like. \n    \n    render slot implicit();\n\n    if(condition) {\n        render slot implicit();\n    }\n\n    // Slots can also accept arguments that will provided as extrusions to the overrider. These arguments are given default values if provided\n    define slot withArguments(int arg0 = GetArgument(), string name = "Matt") {\n        Text("arg0 is: " + arg0);\n        Text("Name is: " + name);\n    }\n\n    render slot withArguments(10, "Franz"); // override the default arguments with different values\n    render slot withArguments(30, "Lea"); // override the default arguments with different values\n\n    // The usual case is that you define a slot once and render it only once. There is a shorthand for this. \n    // this defines and renders the slot in a single statement.\n    slot usingShorthand() {\n        Text("Default body");\n    }\n\n\n}\n\n// there are two variations of using slots. We will build off the last slots example here.\ntemplate UsingSlotsExample : UsingSlotsExample() {\n\n    SlotExample() {\n        // start of override implicit\n        Text("This is overriding the default slot");\n        Text("the default override must come before any explicit overrides or you will get compile errors");\n        // end of override implicit\n\n        override withArguments [arg0, name] {\n            Text("This will override the slot called `withArguments`. The arguments are provided as extrusions, but you do not have to use them");\n            // when overriding a slot, you replace the default block with your override. If you want to still invoke the default body, \n            // you can do so via the `render default` declaration.\n\n            render default; // invokes the default body\n            render default; // invokes the default body again, you can do this as much as you want, but you don\'t have to\n        }\n\n        override usingShorthand {\n            Text("Override the shorthand slot, its not different than the long version from the overrider\'s perspective");\n        }\n\n    }\n\n}\n')),(0,o.kt)("h2",{id:"portals"},"Portals"),(0,o.kt)("p",null,"Portals are kind of like a reverse slot. It is a way to inject content elsewhere in the app while still\nhaving a binding scope that is local to the element. A great example of this is a tooltip or a modal dialog."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'template PortalExample : PortalExample() {\n\n    // there are two parts to the syntax, the first is what you want teleported. In this case we want to show our \n    // \'Confirm\' button in a modal overlay. However we haven\'t yet rendered the modal layer because it natually must \n    // appear on top of the rest of our UI.\n    teleport->("Modal") {\n        // any bindings will run at this point and all context is lexical \n        if(!isConfirmed) {\n            Button("Confirm", mouse:click = isConfirmed = true);\n        }\n    }\n\n    //... later in another template we will render the modal itself\n\n    // Modal.ui\n    render portal("Modal"); // this is where our Button element actually renders.\n    // we are able to use the button in the binding scope of our template but it is somewhere completely different in the hierarchy\n    // important! this also means that it will be laid out and styled as though it\'s parent were the parent of the portal,\n    // it is completely disconnected from its original usage except for bindings!\n\n}\n\n')),(0,o.kt)("h2",{id:"decorators"},"Decorators"),(0,o.kt)("p",null,"Decorators are ways to inject behavior into elements that already defined. Example use cases might be we want to track some analytics\nto see how often certain UIs are being used, or we want certain actions to trigger a route state change, or we need a way to\nadd tooltips to elements without refactoring the elements to be tooltip aware."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'template DecoratorExample : DecoratorExample() {\n\n    // lets turn this button into something that is able to switch between menu screens. \n    // We could add a click handler here that does this logic, but it would be better if we \n    // could hook into a menu transition system that we previously created.\n    Button("Take me there!");\n\n    // using a decorator (which can be user defined) we add functionality that intercepts the button click\n    // and invokes our route transition instead. We didn\'t even alter the button to do this\n    @RouterLink("/game/main_menu")\n    Button("Take me there!");\n\n    // Decorators can also accept arbitrary bindings. In this case I extended the Button to also track how many times it was clicked,\n    // And setup an analytics category with an identifier. Button itself didn\'t change at all\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n\n    // We can combine as many decorators as we like. Here is the button with both analytics and routing attached\n    @RouterLink("/game/main_menu")\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n\n}\n')),(0,o.kt)("h2",{id:"containers-and-typography"},"Containers and Typography"),(0,o.kt)("p",null,"Containers are like templates but without the template\nYou can provide default handlers, decorators and binding values\nand even require it to have children, not to have children, or only allow children\nof a certain type. Containers may only appear at the top level in a .ui file\nand cannot be defined inside of a template or function body"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'container Container : CompilerTest.ContainerElement(style = [@container-test],mouse:click = () => Debug.Log("Clicked Container"),attr:container = "true");\n\n\n// an untyped container implictly extends `UIDefaultUntypedContainer` and can still accept\n// styling, attributes, input handlers, and decorators but no bindings (because the backing\n// type doesn\'t have any fields or methods to bind to).\ncontainer UntypedContainer(style = [@untyped]);\n\n// You can make containers generic if you like. The type `T` in this case will be in scope\n// for any bindings on the container but not for any of its children. Here we use a generic\n// where the backing class ignores the generic type\ncontainer GenericContainer<T>(attr:typeName = typeof(T));\n\n\n// This time we use a backing type that happens to be generic, but the type is not\n// the type of our container, which is totally fine.\ncontainer GenericContainerMismatch<T> : CompilerTest.GenericContainer<string> (attr:typeName = typeof(T));\n\n// This time we use a backing type that happens to be generic, this time the container\n// generic and the backing class generic match, whatever type you pass into the\n// container will be used to instantiate the backing type\ncontainer GenericContainerMatch<T> : CompilerTest.GenericContainer<T> (attr:typeName = typeof(T));\n\n// any decorators you put on the container definition will be implicitly carried to their call sites too\n@ClickTracker("Group1", category = "Category")\ncontainer AnnotatedContainer();\n\n// Using containers is just like using other elements, they accept bindings, styles, attributes\n// etc and can have children or not.\nUntypedContainer(style = [@untyped]);\nGenericContainerMismatch<string>();\nGenericContainerMatch<float3>();\nGenericContainer<string>();\nGenericContainer<int>();\n\nAnnotatedContainer(); // implicitly carries the @ClickTracker decorator here\n\n// Containers can also extrude their values just like all other elements\nGenericContainerMatch<float>() [$element, value] {\n    Text("Value is: " + value);\n    Text("Element Type" + $element.GetType());\n    run value++; // the extrusions are by reference too, like normal\n}\n\nContainer(attr:container = "override", mouse:click = () => Debug.Log("Clicked")) {\n    Text("In a container");\n}\n\n')),(0,o.kt)("p",null,"Typography can also be defined in the same way as containers by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"typography")," keyword\nit behaves identically to ",(0,o.kt)("inlineCode",{parentName:"p"},"container")," except cannot accept a backing class, has no children, and\nbehaves identically to a Text() element. This lets you define various typography elements without\nalways passing styles to them"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"typography Label()\n")),(0,o.kt)("h2",{id:"string-interpolation"},"String Interpolation"),(0,o.kt)("p",null,"String interpolation works in the template language just like in C#\nIf you add a $ before the quote in a string, any expressions within { } are evaluated\nThis works anywhere strings are accepted, not just text elements"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Text("Hello {19 + 51}"); // prints "Hello {19 + 51}"\nText($"Hello {19 + 51}"); // prints "Hello 70"\n')),(0,o.kt)("h2",{id:"markers"},"Markers"),(0,o.kt)("p",null," Markers are how we can navigate element hierarchies.\nthey are defined in templates via the ",(0,o.kt)("inlineCode",{parentName:"p"},"marker")," keyword and\nthey accept an identifier as a name.\nonce defined they can be passed around, but they do not become\nvalid until after their block ends"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'marker x {\n    // x not accessible here\n    Text("marker element 0");\n    Div() { // 1\n        Text("marker element 2");\n        Text("marker element 3");\n        Text("marker element 4");\n        Text("marker element 5");\n    }\n    Text("Third marker element 6");\n    Div() { // 7\n        Div() { // 8\n            Text("marker element 9");\n        }\n    }\n}\n\n// outside the marker block, x follows all the regular scoping rules.\nrun PrintMarker(x);\n')),(0,o.kt)("p",null,"Once you have a marker it gives you access to all the elements within it via enumerators\nnote: this in C#, not in the template language but you could do the same thing in the template via a run block"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public void PrintMarker(HierarchyMarker marker) {\n\n    UIElement parent = marker.GetParent();\n    UIElement firstMarkedElement = marker.GetFirstElement();\n    int elementCount = marker.ElementCount; // 10\n    bool hasElements = marker.HasElements; \n    bool isValue = marker.IsValid; // returns if the marker has elements and is still valid for the current frame\n\n    HierarchyMarker unscoped = marker.GetUnscoped(); // returns a new marker as though the parent element has been the only marked element\n\n    // create a marker as though `element` had been the only marked element\n    // only valid during the binding run, and must be called after the target \n    // element has been visited by the binding pass. \n\n    HierarchyMarker fromElement = HierarchyMarker.FromElement(someInstance); \n\n    // enumerate all top level elements => 0, 1, 6, 7\n    foreach (UIElement element in marker.GetSiblingEnumerator()) {\n        Debug.Log("Sibling: " + element);\n    }\n\n    // enumerate all elements regardless of hierarchy position \n    foreach (UIElement element in marker.GetEnumerator()) {\n        Debug.Log("Element: " + element);\n    }\n\n    // enumerates up the tree, will not return anything inside the { } block, rather the ancestors\n    foreach (UIElement parent in marker.GetAncestorEnumerator()) {\n        Debug.Log("Ancestor: " + parent);\n    }\n\n    // skips the first level and returns the children. in this example => 2, 3, 4, 5, 8\n    foreach (UIElement child in marker.GetChildrenEnumerator()) {\n        Debug.Log("Child: " + child);\n    }\n    \n    // skips the first level and returns the descendents. in this example => 2, 3, 4, 5, 8, 9\n    foreach (UIElement descendent in marker.GetDescendentEnumerator()) {\n        Debug.Log("Descendent: " + descendent);\n    }\n\n}\n\n// Markers can be used for a lot more than just iteration however. They can also allow elements\n// to be moved around in the hierarchy.\n\nmarker m0 {\n// marker bindings run at the time they are encountered in the hierarchy, like normal\n    Text("Inside of a marker");\n}\n\n// but we can choose to draw them some where else via the render marker function\nDiv() {\n    Text("Somewhere else");\n    render marker(m0); // m0 renders here, not where it was defined!\n}\n\n// sometimes we aren\'t sure if something should be displayed or not. For this purpose we can use a deferred marker.\n\n// marker will run the bindings here and the elements touched will be enabled as usual\n// however if there is no render marker() call for this marker, these elements will not\n// be part of layout and will not be rendered at all!\nmarker:defer m1 {\n    Text("Maybe show me");\n}\n\n// we can decide later if we want to use it or not\n\nif(someCondition) {\n    render marker(m1);\n}\n\n// markers can only be rendered once. If a marker is rendered multliple times, the last one wins\nrender marker(m1);\nrender marker(m1);\nrender marker(m1);\n\n// markers are just variables, they can be passed around to functions too\nElement(markerField = m1); // this element might decide to render the marker m1\n\n// You can also explicitly hide/show markers\n$runtime.HideMarker(marker);\n$runtime.ShowMarker(marker);\n')),(0,o.kt)("h2",{id:"lifecycle-hooks"},"Lifecycle Hooks"),(0,o.kt)("p",null,"Elements can declare life cycle handles directly in templates as well as in C#\nLike the template method, this handle accepts not arguments, but does in inject\nand element reference via the ",(0,o.kt)("inlineCode",{parentName:"p"},"$this")," symbol which you can optionally use."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Div(\n    on:enable = ()     { Debug.Log("Enabled " + $this); },\n    on:create = ()     { Debug.Log("Created " + $this); },\n    on:update = ()     { Debug.Log("Updated " + $this); },\n    on:postUpdate = () { Debug.Log("Post Updated " + $this); },\n    on:disable = ()    { Debug.Log("Disable " + $this); },\n    on:destroy = ()    { Debug.Log("Destroy " + $this); }\n);\n\n')),(0,o.kt)("h2",{id:"expression-extrusion"},"Expression Extrusion"),(0,o.kt)("p",null,"Similar to how we can extrude values in templates, expressions can also extrude values\nnote the difference though: there is a required -> arrow and we don't support the ",(0,o.kt)("inlineCode",{parentName:"p"},"as"),"\nsyntax within the extrusion identifier block. Also when nesting extrusion blocks\na semi colon is required at the end just like any other statement type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"state KeyFrameAnimation<Color> anim = new KeyFrameAnimation<Color>() -> [a] {\na.SetDuration(1000);\na.AddKeyFrame(0, Color.red);\na.AddKeyFrame(1000, Color.yellow);\n\n    curveAnim -> [c] {\n        c.Thing();\n        c.Thing();\n        c.Thing();\n        c.Thing();\n        c.Thing();\n    };\n\n};\n\n")),(0,o.kt)("h2",{id:"modules"},"Modules"),(0,o.kt)("p",null,"The idea behind modules is that they are portable between projects. They packages templates, styles, and assets together\nand serve as a basis for resolving imports within .ui files. Modules can have dependencies on other modules."),(0,o.kt)("p",null,"There are no visibility rules for elements, all template / element declarations are considered to be public."),(0,o.kt)("p",null,"If a module (A) includes a dependency on another module (B) and (B) declares a dependency on (C), and (A) wants to\nreference something in (C), (A) must declare a dependency on (C), it does NOT automatically inherit (B)'s dependency on (C)"),(0,o.kt)("p",null,"Modules are file system scoped and cannot be nested. A template & style file belong to the nearest module at the same level\nor above them in the file tree. If no module asset exists in the project, it is an error."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// some file.ui\n\nimport \"SomeModuleName\";\nimport \"OtherModule\" as Lib; // import 'OtherModule' and alias it as 'Lib'\n\n// A Module (which is an asset in Unity) can define a list of 'implicit' imports\n// and these function as though the user had written `import \"SomeModule\"` \n// in every file belonging to that module\n\ntemplate Something {\n\n    // the scope resolution operator is used to reference elements residing in imported modules\n    SomeModuleName::Button();\n\n    Lib::Button(); // using the alias \n    OtherModule::Button(); // using the full name, same result as the line above\n\n    Button(); // if no scope resolution operator is present, resolution is as follows\n              // 1. If the 'current' module in which this file is defined defines \n              //    a template called 'Button', then we us it. \n              // 2. If the current module does not define 'Button', we look all the \n              //    imported modules declared in this file and search for 'Button'. \n              //    If one is found, we use it. If multiple imported modules define\n              //    'Button', we throw an Ambiguous import error and the user is required\n              //    to use the :: operator to specify which version of 'Button' to use\n\n}\n")))}m.isMDXComponent=!0}}]);