"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[68782],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},67805:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={},l="Setting Up a Canvas Painter",o={unversionedId:"canvas/canvas-painter-setup",id:"canvas/canvas-painter-setup",title:"Setting Up a Canvas Painter",description:"Painters are custom rendering components that can draw using the Canvas API. They attach to UI elements and execute during the paint phase, allowing you to add custom vector graphics, animations, and effects.",source:"@site/docs/canvas/canvas-painter-setup.md",sourceDirName:"canvas",slug:"/canvas/canvas-painter-setup",permalink:"/EvolveUIDocs/docs/canvas/canvas-painter-setup",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Canvas Guide",permalink:"/EvolveUIDocs/docs/canvas/canvas-guide"},next:{title:"Layout",permalink:"/EvolveUIDocs/docs/layout/"}},s={},p=[{value:"Basic Painter Structure",id:"basic-painter-structure",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"The Attach Method",id:"the-attach-method",level:3},{value:"The PaintDetach Handler",id:"the-paintdetach-handler",level:3},{value:"The Paint Method",id:"the-paint-method",level:3},{value:"Calling Next()",id:"calling-next",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Accessing Element Information",id:"accessing-element-information",level:2},{value:"Loading Resources",id:"loading-resources",level:2},{value:"Paint Attachment Points",id:"paint-attachment-points",level:2},{value:"Skipping Default Rendering",id:"skipping-default-rendering",level:2},{value:"Tips",id:"tips",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"setting-up-a-canvas-painter"},"Setting Up a Canvas Painter"),(0,r.kt)("p",null,"Painters are custom rendering components that can draw using the Canvas API. They attach to UI elements and execute during the paint phase, allowing you to add custom vector graphics, animations, and effects."),(0,r.kt)("h2",{id:"basic-painter-structure"},"Basic Painter Structure"),(0,r.kt)("p",null,"A painter extends the ",(0,r.kt)("inlineCode",{parentName:"p"},"Painter")," base class and implements two key methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using EvolveUI;\nusing EvolveUI.Rendering;\nusing UnityEngine;\nusing Canvas = EvolveUI.Rendering.Canvas;\n\npublic class MyPainter : Painter {\n\n    private Canvas canvas;\n\n    // Called when the painter is attached to an element\n    public override PaintDetach Attach(ElementId elementId, PaintAttachment attachment) {\n        // Create the canvas instance\n        canvas = new Canvas(Assets);\n\n        // Return a detach handler to clean up when the element is destroyed\n        return new PaintDetach(this, static (paintInfo) => {\n            ((MyPainter)paintInfo.cookie).canvas.Dispose();\n        });\n    }\n\n    // Called every frame to render\n    protected override void Paint(Gfx gfx, StyleResult styleResult) {\n        // Call Next() to continue the paint chain (can be before or after your drawing)\n        Next();\n\n        // Clear previous frame's geometry\n        canvas.Clear();\n\n        // Draw using the Canvas API\n        canvas.SetFillColor(255, 100, 100, 255);\n        canvas.FillRect(0, 0, 200, 100);\n\n        // Submit the canvas to be rendered\n        gfx.DrawCanvas(canvas);\n    }\n}\n")),(0,r.kt)("h2",{id:"key-concepts"},"Key Concepts"),(0,r.kt)("h3",{id:"the-attach-method"},"The Attach Method"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Attach")," is called once when the painter is first connected to an element. Use it to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create your ",(0,r.kt)("inlineCode",{parentName:"li"},"Canvas")," instance"),(0,r.kt)("li",{parentName:"ul"},"Load textures or fonts"),(0,r.kt)("li",{parentName:"ul"},"Initialize any state")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Assets")," property provides access to ",(0,r.kt)("inlineCode",{parentName:"p"},"UIAssetManager")," for loading resources."),(0,r.kt)("h3",{id:"the-paintdetach-handler"},"The PaintDetach Handler"),(0,r.kt)("p",null,"Return a ",(0,r.kt)("inlineCode",{parentName:"p"},"PaintDetach")," to clean up resources when the element is destroyed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"return new PaintDetach(this, static (paintInfo) => {\n    var painter = (MyPainter)paintInfo.cookie;\n    painter.canvas.Dispose();\n    // Clean up other resources...\n});\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cookie")," parameter passes your painter instance to the static delegate."),(0,r.kt)("h3",{id:"the-paint-method"},"The Paint Method"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Paint")," is called every frame. The parameters provide:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gfx")," - Graphics context for submitting draw calls and accessing time info"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"styleResult")," - The element's computed styles and layout information")),(0,r.kt)("h3",{id:"calling-next"},"Calling Next()"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Next()")," continues the paint chain to other painters and the default element rendering. Where you call it matters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// Draw AFTER the element (overlay)\nprotected override void Paint(Gfx gfx, StyleResult styleResult) {\n    Next();  // Element renders first\n    // Your drawing goes on top\n    canvas.Clear();\n    canvas.SetFillColor(255, 0, 0, 128);\n    canvas.FillRect(0, 0, 100, 100);\n    gfx.DrawCanvas(canvas);\n}\n\n// Draw BEFORE the element (background)\nprotected override void Paint(Gfx gfx, StyleResult styleResult) {\n    canvas.Clear();\n    canvas.SetFillColor(0, 0, 255, 128);\n    canvas.FillRect(0, 0, 100, 100);\n    gfx.DrawCanvas(canvas);\n    Next();  // Element renders on top\n}\n")),(0,r.kt)("h2",{id:"complete-example"},"Complete Example"),(0,r.kt)("p",null,"Here's a painter that draws an animated gradient background:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using EvolveUI;\nusing EvolveUI.Rendering;\nusing UnityEngine;\nusing Canvas = EvolveUI.Rendering.Canvas;\n\npublic class AnimatedGradientPainter : Painter {\n\n    private Canvas canvas;\n    private float time;\n\n    public override PaintDetach Attach(ElementId elementId, PaintAttachment attachment) {\n        canvas = new Canvas(Assets);\n\n        return new PaintDetach(this, static (paintInfo) => {\n            ((AnimatedGradientPainter)paintInfo.cookie).canvas.Dispose();\n        });\n    }\n\n    protected override void Paint(Gfx gfx, StyleResult styleResult) {\n        Next();\n\n        canvas.Clear();\n        time += gfx.timeInfo.deltaTime;\n\n        // Get the element's layout size\n        var size = styleResult.GetLayoutSize();\n        float width = size.x;\n        float height = size.y;\n\n        // Animated color cycling\n        float hue1 = (time * 30) % 360;\n        float hue2 = (time * 30 + 180) % 360;\n        Color color1 = Color.HSVToRGB(hue1 / 360f, 0.7f, 0.9f);\n        Color color2 = Color.HSVToRGB(hue2 / 360f, 0.7f, 0.9f);\n\n        // Draw gradient background\n        canvas.SetLinearGradient(0, 0, width, height,\n            new Color32((byte)(color1.r * 255), (byte)(color1.g * 255), (byte)(color1.b * 255), 255),\n            new Color32((byte)(color2.r * 255), (byte)(color2.g * 255), (byte)(color2.b * 255), 255));\n        canvas.FillRect(0, 0, width, height);\n\n        gfx.DrawCanvas(canvas);\n    }\n}\n")),(0,r.kt)("h2",{id:"accessing-element-information"},"Accessing Element Information"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"StyleResult")," provides access to the element's computed properties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"protected override void Paint(Gfx gfx, StyleResult styleResult) {\n    // Layout information\n    var size = styleResult.GetLayoutSize();      // Element dimensions\n    var position = styleResult.GetLayoutPosition(); // Element position\n\n    // Style properties\n    float opacity = styleResult.Opacity;\n    Color textColor = styleResult.TextColor;\n    Color bgColor = styleResult.BackgroundColor;\n\n    // ... use these values in your drawing\n}\n")),(0,r.kt)("h2",{id:"loading-resources"},"Loading Resources"),(0,r.kt)("p",null,"Load fonts and textures in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Attach")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'private Canvas canvas;\nprivate VectorFont titleFont;\nprivate TextureId patternTexture;\n\npublic override PaintDetach Attach(ElementId elementId, PaintAttachment attachment) {\n    canvas = new Canvas(Assets);\n\n    // Load a font\n    titleFont = Assets.LoadVectorFont("/path/to/font.ttf");\n\n    // Register a texture for patterns\n    Texture2D tex = Resources.Load<Texture2D>("MyPattern");\n    patternTexture = Assets.RegisterTexture(tex);\n\n    return new PaintDetach(this, static (paintInfo) => {\n        ((MyPainter)paintInfo.cookie).canvas.Dispose();\n    });\n}\n\nprotected override void Paint(Gfx gfx, StyleResult styleResult) {\n    Next();\n    canvas.Clear();\n\n    // Use the loaded font\n    canvas.SetFont(titleFont);\n    canvas.SetFontSize(32);\n    canvas.SetTextFillColor(Color.white);\n    canvas.Text(10, 10, 400, "Hello World");\n\n    // Use the pattern texture\n    canvas.SetPatternTexture(patternTexture);\n    canvas.SetPatternMode(PatternSpace.Bounds, PatternSizing.Tile, PatternRepeat.Repeat);\n    canvas.SetPatternTileSize(0.2f, 0.2f);\n    canvas.FillRect(0, 100, 200, 200);\n    canvas.ClearPattern();\n\n    gfx.DrawCanvas(canvas);\n}\n')),(0,r.kt)("h2",{id:"paint-attachment-points"},"Paint Attachment Points"),(0,r.kt)("p",null,"When attaching a painter to an element, you specify when it should run in the paint order:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Attachment"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BeforeEverything")),(0,r.kt)("td",{parentName:"tr",align:null},"Before any element rendering")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BeforeShadow")),(0,r.kt)("td",{parentName:"tr",align:null},"Before shadow rendering")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AfterShadow")),(0,r.kt)("td",{parentName:"tr",align:null},"After shadow, before frame")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BeforeFrame")),(0,r.kt)("td",{parentName:"tr",align:null},"Before frame/border rendering")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AfterFrame")),(0,r.kt)("td",{parentName:"tr",align:null},"After frame, before element content")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BeforeElement")),(0,r.kt)("td",{parentName:"tr",align:null},"Just before element content")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AfterElement")),(0,r.kt)("td",{parentName:"tr",align:null},"Just after element content")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BeforeChildren")),(0,r.kt)("td",{parentName:"tr",align:null},"Before child elements render")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AfterChildren")),(0,r.kt)("td",{parentName:"tr",align:null},"After child elements render")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AfterEverything")),(0,r.kt)("td",{parentName:"tr",align:null},"After all element rendering")))),(0,r.kt)("h2",{id:"skipping-default-rendering"},"Skipping Default Rendering"),(0,r.kt)("p",null,"You can skip the element's default rendering or its children:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"protected override void Paint(Gfx gfx, StyleResult styleResult) {\n    // Skip the element's normal background/border rendering\n    SkipDefaultPainting = true;\n\n    // Skip rendering child elements\n    SkipChildrenPainting = true;\n\n    // Draw your custom content instead\n    canvas.Clear();\n    // ...\n    gfx.DrawCanvas(canvas);\n\n    Next();\n}\n")),(0,r.kt)("h2",{id:"tips"},"Tips"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Always call ",(0,r.kt)("inlineCode",{parentName:"strong"},"canvas.Clear()"))," at the start of ",(0,r.kt)("inlineCode",{parentName:"p"},"Paint()")," to remove the previous frame's geometry.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Always call ",(0,r.kt)("inlineCode",{parentName:"strong"},"gfx.DrawCanvas(canvas)"))," to submit your drawing. Without this, nothing renders.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Call ",(0,r.kt)("inlineCode",{parentName:"strong"},"Next()"))," to continue the paint chain. Omitting it will prevent other painters and default rendering.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Dispose the canvas")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"PaintDetach")," handler to avoid memory leaks.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Use ",(0,r.kt)("inlineCode",{parentName:"strong"},"gfx.timeInfo.deltaTime"))," for smooth animations that are frame-rate independent."))))}d.isMDXComponent=!0}}]);