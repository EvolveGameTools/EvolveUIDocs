"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[937],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,f=c["".concat(l,".").concat(m)]||c[m]||p[m]||i;return n?r.createElement(f,a(a({ref:t},d),{},{components:n})):r.createElement(f,a({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,a[1]=s;for(var u=2;u<i;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},22499:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=n(87462),o=(n(67294),n(3905));const i={},a="Modules",s={unversionedId:"templates/modules",id:"templates/modules",title:"Modules",description:"The idea behind modules is that they are portable between projects. They package templates, styles, and assets together",source:"@site/docs/templates/modules.md",sourceDirName:"templates",slug:"/templates/modules",permalink:"/EvolveUIDocs/docs/templates/modules",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Grid Layout",permalink:"/EvolveUIDocs/docs/templates/grid_layout_docs"},next:{title:"Lifecycle and Identity",permalink:"/EvolveUIDocs/docs/templates/structural_identity"}},l={},u=[],d={toc:u};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"modules"},"Modules"),(0,o.kt)("p",null,"The idea behind modules is that they are portable between projects. They package templates, styles, and assets together\nand serve as a basis for resolving imports within .ui files. Modules can have dependencies on other modules."),(0,o.kt)("p",null,"There are no visibility rules for elements, all template / element declarations are considered to be public."),(0,o.kt)("p",null,"If a module (A) includes a dependency on another module (B) and (B) declares a dependency on (C), and (A) wants to\nreference something in (C), (A) must declare a dependency on (C), it does NOT automatically inherit (B)'s dependency on (C)"),(0,o.kt)("p",null,"Modules are file system scoped and cannot be nested. A template & style file belong to the nearest module at the same level\nor above them in the file tree. If no module asset exists in the project, it is an error."),(0,o.kt)("p",null,"When resolving names for templates & styles, the module in which the template or style is being used is first searched.\nIf there is a template or style that is found, then it is used. If we didn't find the target in the local module, then\nall of the auto imports and explicit imports are searched. If there is only one match then it is taken. If multiple matches\noccur then an error is shown and you need to explicitly disambiguate using a ",(0,o.kt)("inlineCode",{parentName:"p"},"ModuleAlias::YourThing")," fully qualified identifier."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// some file.ui\n\nimport SomeModuleName;\nimport OtherModule as Lib; // import 'OtherModule' and alias it as 'Lib'\n\n// A Module (which is an asset in Unity) can define a list of auto imports\n// and these function as though the user had written `import SomeModule` \n// in every file belonging to that module\n\ntemplate Something render {\n\n    // the scope resolution operator is used to reference elements residing in imported modules\n    SomeModuleName::Button();\n\n    Lib::Button(); // using the alias \n    OtherModule::Button(); // using the full name, same result as the line above\n\n    Button(); // if no scope resolution operator is present, resolution is as follows\n              // 1. If the 'current' module in which this file is defined defines \n              //    a template called 'Button', then we us it. \n              // 2. If the current module does not define 'Button', we look all the \n              //    imported modules declared in this file and search for 'Button'. \n              //    If one is found, we use it. If multiple imported modules define\n              //    'Button', we throw an Ambiguous import error and the user is required\n              //    to use the :: operator to specify which version of 'Button' to use\n\n}\n")))}c.isMDXComponent=!0}}]);