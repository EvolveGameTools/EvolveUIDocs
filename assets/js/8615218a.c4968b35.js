"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[22252],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>c});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=p(n),m=l,c=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(c,o(o({ref:t},h),{},{components:n})):a.createElement(c,o({ref:t},h))}));function c(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},79995:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(87462),l=(n(67294),n(3905));const i={},o="Layout",r={unversionedId:"layout/index",id:"layout/index",title:"Layout",description:"Layout is probably the most difficult topic in any UI system. It's not only how the API gets used, but it is often a",source:"@site/docs/layout/index.md",sourceDirName:"layout",slug:"/layout/",permalink:"/EvolveUIDocs/docs/layout/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Setting Up a Canvas Painter",permalink:"/EvolveUIDocs/docs/canvas/canvas-painter-setup"},next:{title:"start",permalink:"/EvolveUIDocs/docs/start/"}},s={},p=[{value:"The basics",id:"the-basics",level:3},{value:"The box model",id:"the-box-model",level:3},{value:"Templates",id:"templates",level:3},{value:"Typography Size and Wrapping",id:"typography-size-and-wrapping",level:3},{value:"Sizes",id:"sizes",level:3},{value:"Stretching",id:"stretching",level:3},{value:"Algorithms",id:"algorithms",level:2},{value:"Horizontal and Vertical",id:"horizontal-and-vertical",level:3},{value:"Horizontal and Vertical Wrap",id:"horizontal-and-vertical-wrap",level:3},{value:"Stack",id:"stack",level:3},{value:"Grid",id:"grid",level:3}],h={toc:p};function d(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"layout"},"Layout"),(0,l.kt)("p",null,"Layout is probably the most difficult topic in any UI system. It's not only how the API gets used, but it is often a\nmindset about how to approach the problem at hand. Sometimes you get lucky and the design you are implementing\nis simple enough that built in layout components can mostly get you there, but in almost every design I've ever\npersonally worked with, I needed to get my hands dirty and get creative with how the layout was implemented. "),(0,l.kt)("p",null,"The goal of this document is to orient you with 'how-to-think-about-layout' in Evolve. "),(0,l.kt)("h3",{id:"the-basics"},"The basics"),(0,l.kt)("p",null,"We'll start relatively simple. We have two cases: ",(0,l.kt)("inlineCode",{parentName:"p"},"template")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"typography"),". Both cases follow the same default rule:\nthey size themselves according to their content. If there is no content, the size is 0 by default. "),(0,l.kt)("p",null,"So what is 'content'? This can be text content in the case of ",(0,l.kt)("inlineCode",{parentName:"p"},"typogrophy"),", padding, and/or other child elements. "),(0,l.kt)("h3",{id:"the-box-model"},"The box model"),(0,l.kt)("p",null,"Evolve uses the standard CSS border-box model.  "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"+-----------------------------+\n|         Margin              |\n|  +---------------------+    |\n|  |      Border         |    |\n|  |  +---------------+  |    |\n|  |  |   Padding     |  |    |\n|  |  |  +---------+  |  |    |\n|  |  |  | Content |  |  |    |\n|  |  |  +---------+  |  |    |\n|  |  +---------------+  |    |\n|  +---------------------+    |\n+-----------------------------+\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Margin -- Space between sibling elements in "),(0,l.kt)("li",{parentName:"ul"},"Padding -- Space between the edge of element's border and it's content"),(0,l.kt)("li",{parentName:"ul"},"Border -- Space between the theoretical edge of the element and it's padding "),(0,l.kt)("li",{parentName:"ul"},"Content -- All the things inside the element, ie text, images, other elements")),(0,l.kt)("h3",{id:"templates"},"Templates"),(0,l.kt)("p",null,"Templates will default to their content size on both the width and\nthe height axis, and will arrange their children vertically. A side effect of defaulting to content size is that\nby default, with no content, an element's size is 0 on both width and height. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c#"},"template Element; // no content, no style means these have no size unless they have content. \ntemplate Basics {\n    // 3 elements with no size means the parent has no size. \n    render {\n        Element();\n        Element();\n        Element();\n    }\n}\n")),(0,l.kt)("p",null,"If we were to render this template, we'd see nothing. Let's give those some sizes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c#"},"style big {\n    PreferredSize = 300px;\n    BackgroundColor = red;\n}\nstyle small {\n    PreferredSize = 100px;\n    BackgroundColor = blue;\n}\ntemplate Element; // no content, no style means these have no size unless they have content. \ntemplate Basics {\n    // 3 elements with no size means the parent has no size. \n    render {\n        Element(style = [@small]);\n        Element(style = [@big]);\n        Element(style = [@small]);\n    }\n}\n")),(0,l.kt)("p",null,"This would render the boxes vertically with their respective sizes, so the total width of ",(0,l.kt)("inlineCode",{parentName:"p"},"Basics")," would be 300px,\nand the total height would be ",(0,l.kt)("inlineCode",{parentName:"p"},"500px")),(0,l.kt)("p",null,"We could change this to a horizontal layout like this: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c#"},"// the <> syntax matches based on an element name\nstyle <Basics> {\n    LayoutType = Horizontal;\n}\n\nstyle big {\n    PreferredSize = 300px;\n}\n\nstyle small {\n    PreferredSize = 100px;\n}\n\ntemplate Element; \n\ntemplate Basics {\n    render {\n        Element(style = [@small]);\n        Element(style = [@big]);\n        Element(style = [@small]);\n    }\n}\n")),(0,l.kt)("p",null,"This would render the boxes vertically with their respective sizes, so the total width of ",(0,l.kt)("inlineCode",{parentName:"p"},"Basics")," would be 500px,\nand the total width would be ",(0,l.kt)("inlineCode",{parentName:"p"},"300px")),(0,l.kt)("h3",{id:"typography-size-and-wrapping"},"Typography Size and Wrapping"),(0,l.kt)("p",null,"Typography actually follows the exact same rules, except that usually when we think about typography elements, we assume\nthey contain some text. So text is content, which means that a ",(0,l.kt)("inlineCode",{parentName:"p"},"typography")," element will default to be as big as its text. "),(0,l.kt)("p",null,"This also means that because the text layout is greedy, unless a text is given a width or some explicit new lines, it\nwill not wrap by default. "),(0,l.kt)("p",null,"In order for text to wrap, it needs to be given a non-content sized width, or it needs to contain new lines and have\nit's ",(0,l.kt)("inlineCode",{parentName:"p"},"LineBreakMode"),"set to ",(0,l.kt)("inlineCode",{parentName:"p"},"NewLinesOnly"),". "),(0,l.kt)("h3",{id:"sizes"},"Sizes"),(0,l.kt)("p",null,"Evolve uses a handful of measurement types to measure elements, paddings, offsets, alignments, etc. The most important\nones are ",(0,l.kt)("a",{parentName:"p",href:"../style/style_types_generated#uimeasurement"},"UIMeasurement")," for sizing elements and\n",(0,l.kt)("a",{parentName:"p",href:"../style/style_types_generated#uispacesize"},"UISpaceSize")," for paddings and margins."),(0,l.kt)("p",null,"Then to actually set an element's size, we use the style properties"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"PreferredWidth"),(0,l.kt)("li",{parentName:"ul"},"PreferredHeight"),(0,l.kt)("li",{parentName:"ul"},"MinWidth"),(0,l.kt)("li",{parentName:"ul"},"MinHeight"),(0,l.kt)("li",{parentName:"ul"},"MaxWidth"),(0,l.kt)("li",{parentName:"ul"},"MaxHeight")),(0,l.kt)("p",null,"We also have the shorthands which set both width and height axes at the same time"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"PreferredSize"),(0,l.kt)("li",{parentName:"ul"},"MinSize"),(0,l.kt)("li",{parentName:"ul"},"MaxSize")),(0,l.kt)("p",null,"We use ",(0,l.kt)("inlineCode",{parentName:"p"},"Preferred")," width/height because the layout system has some ways of increasing/reducing the size of elements\nbased on the algorithm used, ie if the ",(0,l.kt)("inlineCode",{parentName:"p"},"PreferredWidth")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"300px")," but the ",(0,l.kt)("inlineCode",{parentName:"p"},"MaxWidth")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"200px"),", the element will clamp\nto it's max size, disregarding the ",(0,l.kt)("inlineCode",{parentName:"p"},"PreferredWidth")," value."),(0,l.kt)("p",null,"See the docs on style properties for more details. "),(0,l.kt)("h3",{id:"stretching"},"Stretching"),(0,l.kt)("p",null,"A key concept of Evolve's layout system that is not typical of other layout systems you may have seen is ",(0,l.kt)("inlineCode",{parentName:"p"},"stretch"),".\nAny axis of content, padding, or margin can stretch. This is a little similar to FlexBox's FlexGrow but is implemented\ndifferently. "),(0,l.kt)("p",null,"Stretch is divided into parts. We can have as many stretch parts as we want and each is treated equally. This makes\nmore sense with an example. Let's say we want a layout that pushes all the items towards the right. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c#"},'style <MyLayout> {\n    PreferredSize = 500px 1cnt; // 500px means we\n    [attr:stretch = "left"] {\n        PaddingLeft = 1s;\n    }\n}\n\nstyle <Box> {\n    // total layout size is 100px (80px for content and 10px on each side for margin)\n    PreferredSize = 80px;\n    BackgroundColor = yellow;\n    Margin = 10px;\n}\n\ntemplate Box;\ntemplate MyLayout {\n    \n    render {\n        Box();\n        Box();\n        Box();\n    }\n\n}\n\n')),(0,l.kt)("h2",{id:"algorithms"},"Algorithms"),(0,l.kt)("p",null,"Evolve comes with a small handful of layouts you can apply. This will be a deep outline of each of them. They all begin\nthe same way: we first try to resolve any sizes that are computable at layout start time into resolved pixel values.\nThis would be values such ",(0,l.kt)("inlineCode",{parentName:"p"},"em"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"vw"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"vh"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"aw"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ah"),". We do this for all axes on padding, border, margin, and content. "),(0,l.kt)("p",null,"Once we've resolved those fixed sizes we need to detect if a layout paradox exists and remove it. This can happen when\na parent element wants to take on the size of its children, and the child wants to be as big as its parent. This is\nan unsolvable paradox, so we take the approach of making the child have a fixed size of 0. THIS IS A BIG SOURCE OF\nISSUES IN LAYOUTS. If a size goes to zero, and you aren't sure why, its most likely because of this paradox solving so\nbe sure to check that you don't have elements that are sized this way. "),(0,l.kt)("p",null,"Next we apply any margin collapses. Margin collapse is enabled with the properties ",(0,l.kt)("inlineCode",{parentName:"p"},"CollapseSpaceHorizontal")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"CollapseSpaceVertical"),". These are used to basically remove extra space such that the parent's padding and a child's\nmargin collapse into the greater of those. This can also be used to merge margins of child elements in the same way. "),(0,l.kt)("p",null,"Once all of these up-front values are resolved we can start to actually perform layout. The layout algorithm is multi-pass\nbut only when needed. We first perform layout of parents and then children. This (for reasons like stretching) might\nor might not fully resolve the size of the parents. If the parent size is not fully resolved, we continue another layout\npass but this time we go bottom to top, i.e. leaves to roots. This process repeats until the layout is fully solved. As\nelements become fully laid out, they are removed from the tree so any subsequent passes will not waste work on them. "),(0,l.kt)("h3",{id:"horizontal-and-vertical"},"Horizontal and Vertical"),(0,l.kt)("p",null,"Vertical is the default ",(0,l.kt)("inlineCode",{parentName:"p"},"LayoutType"),". It simply arranges elements from top to bottom vertically. Similarly, ",(0,l.kt)("inlineCode",{parentName:"p"},"Horizontal"),"\nlays out elements in exactly the same way, just horizontally. Any property mentioned here is applicable to both. "),(0,l.kt)("h3",{id:"horizontal-and-vertical-wrap"},"Horizontal and Vertical Wrap"),(0,l.kt)("p",null,"These work similarly to standard ",(0,l.kt)("inlineCode",{parentName:"p"},"Horizontal")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Vertical")," but they also support wrapping. Instead of children continuing\nto be laid out outside the boundaries, elements will wrap, creating a new row or column (depending on ",(0,l.kt)("inlineCode",{parentName:"p"},"HorizontalWrap"),"\nor ",(0,l.kt)("inlineCode",{parentName:"p"},"VerticalWrap"),") in which subsequent children will be arranged in. "),(0,l.kt)("h3",{id:"stack"},"Stack"),(0,l.kt)("p",null,"A stack is probably the simplest layout, it arranges elements such that they all stack on top of each other, there is\nvertical or horizontal offsets other than the child's own margins. This basically gives you a canvas to draw elements on\nwhere an element's top and left margins are their offsets from the parent. Very useful but less frequently used. "),(0,l.kt)("h3",{id:"grid"},"Grid"),(0,l.kt)("p",null,"Grids are intended for 2D layouts. Basically you can define a grid on and then slot elements into it. You can either\nlet it fill in elements automatically or specify where certain elements should fit in the grid and how many rows and\ncolumns they should span."))}d.isMDXComponent=!0}}]);