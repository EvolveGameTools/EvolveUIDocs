"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[86164],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},77846:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const o={},i="Lifecycle and Identity",l={unversionedId:"Topics/StructuralIdentity/structural_identity",id:"Topics/StructuralIdentity/structural_identity",title:"Lifecycle and Identity",description:"Evolve's template system works on a concept called Structural Identity. This means that the compiler",source:"@site/docs/Topics/StructuralIdentity/structural_identity.md",sourceDirName:"Topics/StructuralIdentity",slug:"/Topics/StructuralIdentity/structural_identity",permalink:"/EvolveUIDocs/docs/Topics/StructuralIdentity/structural_identity",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Destructive Scopes",permalink:"/EvolveUIDocs/docs/Topics/StructuralIdentity/destructive"},next:{title:"Attributes",permalink:"/EvolveUIDocs/docs/Topics/TopLevelDeclarations/Entities/Members/attributes"}},s={},c=[{value:"Asynchronous Lifecycle",id:"asynchronous-lifecycle",level:3}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"lifecycle-and-identity"},"Lifecycle and Identity"),(0,a.kt)("p",null,"Evolve's template system works on a concept called ",(0,a.kt)("inlineCode",{parentName:"p"},"Structural Identity"),". This means that the compiler\nfigures out which 'scope' an element belongs to and ties that element's lifecycle to the scope. Scopes\nare created whenever their control flow and all elements declared in that scope are bound to its lifecycle."),(0,a.kt)("p",null,"This means we only create elements when we enter a scope for the first time and we disable or destroy elements\nwhen the scope is no longer in use. Every frame as your template execute the system figures out if the control flow\nbeing run was also run last frame or not and decides if it needs to create the elements within this scope or if\nit should use the same instances from last frame. One of the great things about this system is that you can declare\n",(0,a.kt)("inlineCode",{parentName:"p"},"state")," variables anywhere inside of a scope and they will retain their values across frames."),(0,a.kt)("p",null,"Here is how a frame is built for each template in your game."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Was this the first time this scope was entered?",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,a.kt)("inlineCode",{parentName:"li"},"created")," hooks that are defined on the elements"))),(0,a.kt)("li",{parentName:"ul"},"Was this created this frame or previously disabled?",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,a.kt)("inlineCode",{parentName:"li"},"enabled")," hooks"))),(0,a.kt)("li",{parentName:"ul"},"Set all of the per-frame 'bindings' for the currently executing element. This includes:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"parameters"),(0,a.kt)("li",{parentName:"ul"},"non constant styles"),(0,a.kt)("li",{parentName:"ul"},"non constant attributes"))),(0,a.kt)("li",{parentName:"ul"},"invoke any before early input hooks"),(0,a.kt)("li",{parentName:"ul"},"process input"),(0,a.kt)("li",{parentName:"ul"},"invoke any after early input hooks"),(0,a.kt)("li",{parentName:"ul"},"invoke any update hooks"),(0,a.kt)("li",{parentName:"ul"},"invoke any after update input hooks"),(0,a.kt)("li",{parentName:"ul"},"recursively visit all of the children of this template"),(0,a.kt)("li",{parentName:"ul"},"invoke any late input hooks"),(0,a.kt)("li",{parentName:"ul"},"invoke any finish hooks")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'template Example(required bool showGroup1) render {\n    if(showGroup1) {\n        // a new scope is created for the true case \n        // the two text elements below are bound to this scope\n        // if this branch does not execute in a given frame, \n        // all elements that are descendents of this scope will be\n        // disabled (or destroyed if the scope is marked with :destructive)\n        Text("Element 1");\n        Text("Element 2");\n    }\n    else {\n        // a new scope is created for the else case \n        // Element 3 is a member of this scope.\n        Text("Element 3");\n    }\n}\n')),(0,a.kt)("h3",{id:"asynchronous-lifecycle"},"Asynchronous Lifecycle"),(0,a.kt)("p",null,"There are two classes of events which are not executed as your code runs each frame: ",(0,a.kt)("inlineCode",{parentName:"p"},"disable")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"destroy"),"."),(0,a.kt)("p",null,"For performance reasons we only run these handlers at the start of the next frame. It is illegal / undefined behavior\nif you have a disable/destroy handler that uses a closure to close over any fields / state in a template. Generally,\nyou should not have to worry about this because the system makes it very hard to do, but in case you are tempted to\ntrick the system into doing something crazy: you've been warned!"))}p.isMDXComponent=!0}}]);