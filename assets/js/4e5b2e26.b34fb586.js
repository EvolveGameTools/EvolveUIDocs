"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[976],{3905:function(e,n,t){t.d(n,{Zo:function(){return h},kt:function(){return m}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},h=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=d(t),m=a,p=u["".concat(l,".").concat(m)]||u[m]||c[m]||o;return t?i.createElement(p,r(r({ref:n},h),{},{components:t})):i.createElement(p,r({ref:n},h))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var d=2;d<o;d++)r[d]=t[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9877:function(e,n,t){t.r(n),t.d(n,{assets:function(){return h},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),r=["components"],s={},l="Template Syntax",d={unversionedId:"templates/template_syntax",id:"templates/template_syntax",title:"Template Syntax",description:"",source:"@site/docs/templates/template_syntax.mdx",sourceDirName:"templates",slug:"/templates/template_syntax",permalink:"/EvolveUIDocs/docs/templates/template_syntax",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"style_syntax",permalink:"/EvolveUIDocs/docs/templates/style_syntax"}},h={},c=[],u={toc:c};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"template-syntax"},"Template Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Using statements just like in C#\nusing EvolveUI;\nusing EvolveUI.Style;\nusing UnityEngine;\nusing Unity.Mathematics;\nusing CompilerTest;\n\n// Imports work on a module level, once imported, all styles, elements, templates, and functions are available via the imported alias\n// using the scope specifier operator ::.\n// MyModule::SomeElement(style = [@MyModule::some-style])\n// You can also import everything in a module and expose it implicity (without needing the scope operator)\n// but if any naming conflicts occur, an error will be raised and you will need to use the scope operator in order to disambiguate the names.\n// Modules that are imported implictly will still need to provide an alias\nimport "SharedModule" as shared; // import that defines an alias\nimport implicit "SomeModule" as something; // implicit import with an alias\nimport implicit "OtherModule"; // no alias\n\n// Element nodes are shortcuts for defining a C# class extending UIElement. It can define only fields, no methods or properties.\nelement Button {\n\n    string text;\n    string tooltip = "default value goes here optionally";\n\n}\n\n// Templates are defined via the `template` keyword and given a tag name. In this example we create a template based on the\n// `Button` element defined above. It happens to use a tag name `ExampleButton` and is refered to in templates using\n// `ExampleButton()` and not `Button()`.\n// Behind the colon (:) comes the namespace and class path of the backing type. In this case we defined `Button` in the same file\n// but if we wanted to use a C# class instead we would have to refer to it by its namespace. So if you Button type was in\n// namespace `Example.Controls`, the syntax would be `template ExampleButton : Example.Controls.Button`\ntemplate ExampleButton : element Button() {\n\n    Text(text);\n    Text(tooltip);\n\n}\n\n// elements defined in this way can be type referenced with the element<> operator\nelement<Button> button;\nbutton.text = "whatever";\n\n// Templates can also accept generic types. The backing class DOES NOT have to also be generic or use the types provided.\n// Templates can also accept binding arguments like other elements.\ntemplate Generic<T, U> : Example.Generic<T, U>(attr:isGeneric = "true", isCool = true, mouse:click = () => Debug.Log("Awesome")) {\n\n    // we can define variables with the var syntax. `var Type variableName = value;`\n    // variables are re-initialized every frame and do not hold their value across frames\n    var T val = value;\n\n    // state fields work just like variables, but they are persisted across frames. The value assignment runs only once, on creation.\n    state U stateVal = value2;\n\n    state bool x = true;\n\n    // the assignment value for variables and state fields can be any C# expression where the resulting type can be coearsed to the declared var/state type\n    var List<string> strings = GetStringList();\n\n    // to differentiate between running code and running templates, we use the `run` keyword\n    run x = false;\n    run SomeCSharpFunction();\n    run SomethingWithOutParam(out x);\n\n    // this can also be a block, then every statement doesn\'t need a `run` command in front of it\n    run {\n        x = false;\n        SomeCSharpFunction();\n        SomethingWithOutParam(out x);\n    }\n\n}\n\n// Elements are invoked like functions.\ntemplate ElementExample : ElementExample() {\n\n    // elements can accept property bindings if they define them in C# (or via `element` template declaration)\n    ElementWithBinding(value = GetValue());\n\n    // Text primitives accept a string as their default argument\n    // Styles are referenced via the @ symbol. If the style is originating from a module import,\n    // the style must be resolved through the imported alias. \n    Text("Implict argument", style = [@text-style]);\n    Text("Implict argument", style = [@importedModule::label-style]);\n    \n    // While text cannot have a child elements, other primitive container elements like `Div` can\n    Div() {\n        Text("Hello");\n    }   \n\n    // container elements do not have to provide children\n    Div();\n\n    // Templates are also invokable in the same way primitive elements are. Some accept children slots,\n    // some do not. If the element does not expose a slot for children, and children are provided, you will get an error at compile time\n    CharacterList(list = characters);\n\n    // This element exposes a slot for children. If the name of the slot is `implicit` then the user of the element\n    // does not use extra syntax for this. If the name is something else you need to use the `override` keyword with the slot name\n    ThingAcceptingChildren() {\n        \n        Text("I\'m a child in the implicit slot");\n\n        override explicit-slot-name {\n            Text("I\'m a child in an explicitly named slot");\n        }\n\n    }\n\n    // Things with internal state can have that state \'extruded\' via square bracket syntax.\n    // If our `ThingWithExtrusions` defines a field or property `color` and `id`, we can access them\n    // in the nested scope of the template like below. If there are naming conflicts in the scope, you \n    // can alias the extruded values with the `as` keyword. \n    ThingWithExtrusions() [color, id as identifier] {\n        ColorPicker(color = color);\n        TextField(value = identifier);// refer to ThingWithExtrusions.id as `identifier` instead.\n    }\n\n}\n\n// Functions are snippets of code that can be re-used. At compile time they may get inlined and have no performance overhead\ntemplate XYZ : XYZ()  {\n\n    // functions can accept as many arguments as you like. These are then available in the defining scope of the function\n    fn CallMe(int v) {\n        Text("The value is: " + v.ToString());\n    }\n\n    // Functions are called with the `invoke` keyword\n    invoke CallMe(0);\n    invoke CallMe(1);\n    invoke CallMe(2);\n\n    // Functions may also be generically typed\n    fn CallMeGeneric<T, U, V>(T value, U uValue) {\n        Text("The T value is: " + value.ToString());\n        Text("The U type is: " +  uValue.ToString());\n        Text("The V type is: " + typeof(V).ToString());\n    }\n\n    // Calling a generic function requires specifying the types explicitly. This may be relaxed in the future. \n    invoke CallMeGeneric<int, string, List<bool>>(5, "hello");\n    invoke CallMeGeneric<float3, string, float4x4>(new float3(1, 1, 1), "hello");\n\n    // functions can be nested within each other, closures are also fully supported so you don\'t need to worry about scoping\n    fn Outer(int outerValue) {\n        \n        Text("FromOuter");\n        \n        var int closuresAreFine = 20;\n\n        fn Inner() {\n            Text("From Inner: "  + closuresAreFine + outerValue);\n        }\n\n        invoke Inner();\n        run closuresAreFine = 40;\n        invoke Inner();\n        run closuresAreFine = 60;\n        invoke Inner();\n    }\n\n    invoke Outer(10);\n\n    // Functions can expose a body block to be invoked later as the function executes with the `invoke default` directive. \n    // The body block is optional.\n    fn FuncWithBody() {\n        Text("Before body");\n        invoke default;\n        Text("After body");\n    }\n\n    // here is how the body is provided\n    invoke FuncWithBody() {\n        Text("I am the body");\n    }\n\n    // another example, the same function can be invoked with as many body variations as you like\n    invoke FuncWithBody() {\n        Text("I am the body");\n        Text("but i am different");\n    }\n\n    // functions can also define values to be extruded by their body slots. \n    // all the extrusion parameters are initialized to default(type) every frame.\n    // note that the extrusion list here DOES NOT GET PUT INTO THE SCOPE\n    // this is only to signify the signature which body slots get invoked with \n    fn FuncWithBodyAndExtrusions(float x, float y) [int invokeCount, string str, float f] {\n        \n        state int invokeCount = 0; // define state for invokeCount. the extruded int invokeCount is NOT usable and so we define our own \n\n        Text("Before body");\n        \n        invoke implicit(invokeCount, "hello", 57f);\n        run invokeCount++;\n\n        Text("After body");\n\n    }\n\n    // here we use the extrusion parameter `invokeCount` and pass it to our body block\n    invoke FuncWithBodyAndExtrusions() [invokeCount] {\n        Text("The function has run " + invokeCount + " times");\n    }\n\n    // functions can also accept named slots \n\n    @AllowMultipleBodyInvocations\n    fn FnWithSlots() [int callId] {\n        // you can invoke the default body as many times as you like, but you must mark the function as AllowMultipleBodyInvocations,\n        // otherwise the subsequent slot invocations will silently do nothing. Note that this has some overhead because the body slot\n        // must be cloned each time it is invoked, where in the default case we do not have this cloning overhead\n        invoke slot implicit(0);\n        invoke slot implicit(1);\n        invoke slot implicit(2);\n        invoke slot implicit(3);\n        invoke slot implicit(4);\n    }\n    \n    // functions can also accept named slots\n    fn FnWithNamedSlots() [int value] {\n        invoke slot thing(0);\n        invoke slot other(1);\n        invoke slot implicit(2);\n\n        // the name of the slot can be an expression too\n        invoke slot[Math.Random() > 5 ? "thing" : "other"];\n\n        // you can also invoke slots that are not provided, these will silently do nothing \n        invoke slot notHere(3);\n\n        invoke slot["not_defined"](4);\n\n    }\n\n    invoke FnWithNamedSlots() [int value] {\n\n        slot thing {\n            Text("Im in slot \'thing\'");\n        }\n        \n        slot other {\n            Text("Im in slot \'other\'");\n        }\n\n        Text("Everything else is in the implicit slot");\n\n    }\n\n    // an example use case for slots might be content transitions with animations\n\n    // function arguments can also be synchronized to reflect their values into the caller,\n    // as long as the input expression is assignable\n    fn DoubleThis(int val) {\n        run val *= 2;\n    }\n    \n    state int x = 10;\n    state int y = 10;\n    invoke DoubleThis(sync: x);\n    invoke DoubleThis(y);\n    run Debug.Log(x); // output => 20\n    run Debug.Log(y); // output => 10 because it didn\'t sync\n}\n\n// Control flow is done similar to c#, we have if/else, switch, and foreach concepts.\ntemplate ControlFlow : ControlFlow() {\n\n    if(someCondition) {\n        Text("Some condition is true");\n    }\n    else if(!someCondition && somethingElse) {\n        Text("Some condition is false but something else is true");\n    }\n    else {\n        Text("Some condition is false");\n    }\n\n    // switches work on enums or integer-like things (ushort, short, byte, char, etc). There is no fall through, \n    // and the cases must be followed by a set of { }. There is also no break keyword. \n    switch(someIntValueorEnum) {\n        case 0 {\n            \n        }\n\n        case 100 {\n\n        }\n\n        default {\n\n        }\n    }\n\n    // Foreach is like a repeat, it invokes the provided body block multilpe times.\n    // By default the current item is exposed as whatever you name it. The index is available via extrusion\n    foreach(item in list) {\n        Text(item.name)\n    }\n\n    foreach(item in list) [index] {\n        Text(item.name + " is at index " + index);\n    }\n\n    // length is also available\n    foreach(item in list) [index, length] {\n        Text(item.name + " is at index " + index + " out of " + length);\n    }\n\n    // Pagination is also available. (start at item 20, show at most 20)\n    foreach(item in list, start = 10, count = 20) { }\n\n    // Pagination is also available. (start at item 20, show at most 20, every iteration jumps 2 elements)\n    foreach(item in list, start = 10, count = 20, step = 2) { }\n\n    foreach(item in ForeachRange.Times(5)){\n        // loop 5 times\n    }\n    \n    foreach(item in ForeachRange.Inclusive(5, 25)) {\n        // loop with item ranging from 5 to 25\n    }\n\n    foreach(item in ForeachRange.Exclusive(5, 25)) {\n        // loop with item ranging from 5 to 24\n    }\n\n    foreach(item in list, step = 2) {\n        // loop over every 2nd item\n    }\n\n    foreach(item in list, start = 8, end = 12) [index, iteration] {\n        // loop items 8 to 12\n        // index will hold the absolute index\n        // iteration holds the iteration number \n    }\n\n\n    // scope lifecycle can also be controlled. Sometimes you have UI where you know the elements will not be used again for a while\n    // In this case its best to just destroy everything and re-create it when you need it again. In other cases you have elements\n    // you expect to use again shortly and you want to just disable them when the surrounding scope is not entered. \n\n    if(something) {\n        // by default we just disable these elements if the branch is not entered\n        Text("Disable me if something is false");\n    }\n\n    if:destructive(something) {\n        // if we use the `destructive` modifier, we destroy the contents of this scope if the branch is not taken\n        Text("Destroy me if something is false");\n    }\n\n    // All the control flow concepts can be marked as `destructive`\n    if(x) {}\n    else:destructive {\n\n    }\n\n    // all cases are destroyed if not used\n    switch:destructive(thing) {}\n\n    switch(thing) {\n        case:destructive 0 {        }\n        case:destructive 100 {        }\n    }\n\n    foreach:destructive(item in list) {}\n\n}\n\n// Sections allow arbitrary code to be run on certain lifecycle events for a scope.\ntemplate SectionDemo : SectionDemo() {\n\n    state int enableCount = 0;\n    state int disableCount = 0;\n\n    // Create runs when this scope is first created and never again. \n    create {\n        Debug.Log("Created the template")\n    }\n\n    if(x == 0) {\n      \n        // Enable runs when this scope is entered and was not entered last frame\n        enable {\n            enableCount++;\n            Debug.Log("Enabled " + enableCount + "times");\n        }\n\n        // Disable runs when this scope was entered last frame and was not entered this frame.\n        // Note that some bindings may not have run (because we didnt enter certain scopes this frame)\n        // and data *might* be stale, you will have to architect around this\n        disable {\n            disableCount++;\n            Debug.Log("Disabled " + disableCount + "times"); \n        }\n\n        // Destroy runs when the scope was destroyed\n        destroy {\n            Debug.Log("Destroyed!");\n        }\n\n    }\n\n    // It doesn\'t matter where you put these section blocks, they can go anywhere in the template and a single scope can have multiple blocks. Go nuts!\n\n    switch(x) {\n        case 0 {\n            enable { Debug.Log("Enabled!"); }\n            Text("Element"):\n            enable { Debug.Log("Enabled in a second block"); }\n        }\n    }\n\n    create {\n        Debug.Log("Created the template")\n    }\n}\n\n// Slots are ways of exposing pluggable functionality between elements. They are a low overhead way to customize certain elements from the outside\ntemplate SlotExample : SlotExample() {\n\n    // you define a slot by giving it a name. The only special name is `implicit` which allows the user to \n    // write their template as though they were not overriding a slot.\n\n    // Slot definition can happen in two ways. The first way defines the slot, but doesn\'t actually use it.\n    define slot implicit();\n\n    // slot definitions can optionally provide a default body block. This block is used if the slot is not overridden.\n    define slot implicit()  {\n        Text("Default body for slot");\n    }\n\n    // in order to render a slot, you use the `render keyword`. You can render a single slot as many times as you like, wherever you like. \n    \n    render slot implicit();\n\n    if(condition) {\n        render slot implicit();\n    }\n\n    // Slots can also accept arguments that will provided as extrusions to the overrider. These arguments are given default values if provided\n    define slot withArguments(int arg0 = GetArgument(), string name = "Matt") {\n        Text("arg0 is: " + arg0);\n        Text("Name is: " + name);\n    }\n\n    render slot withArguments(10, "Franz"); // override the default arguments with different values\n    render slot withArguments(30, "Lea"); // override the default arguments with different values\n\n    // The usual case is that you define a slot once and render it only once. There is a shorthand for this. \n    // this defines and renders the slot in a single statement.\n    slot usingShorthand() {\n        Text("Default body");\n    }\n\n\n}\n\n// there are two variations of using slots. We will build off the last slots example here.\ntemplate UsingSlotsExample : UsingSlotsExample() {\n\n    SlotExample() {\n        // start of override implicit\n        Text("This is overriding the default slot");\n        Text("the default override must come before any explicit overrides or you will get compile errors");\n        // end of override implicit\n\n        override withArguments [arg0, name] {\n            Text("This will override the slot called `withArguments`. The arguments are provided as extrusions, but you do not have to use them");\n            // when overriding a slot, you replace the default block with your override. If you want to still invoke the default body, \n            // you can do so via the `render default` declaration.\n\n            render default; // invokes the default body\n            render default; // invokes the default body again, you can do this as much as you want, but you don\'t have to\n        }\n\n        override usingShorthand {\n            Text("Override the shorthand slot, its not different than the long version from the overrider\'s perspective");\n        }\n\n    }\n\n}\n\n// Portals are kind of like a reverse slot. It is a way to inject content elsewhere in the app while still\n// having a binding scope that is local to the element. A great example of this is a tooltip or a modal dialog.\ntemplate PortalExample : PortalExample() {\n\n    // there are two parts to the syntax, the first is what you want teleported. In this case we want to show our \n    // \'Confirm\' button in a modal overlay. However we haven\'t yet rendered the modal layer because it natually must \n    // appear on top of the rest of our UI.\n    teleport->("Modal") {\n        // any bindings will run at this point and all context is lexical \n        if(!isConfirmed) {\n            Button("Confirm", mouse:click = isConfirmed = true);\n        }\n    }\n\n    //... later in another template we will render the modal itself\n\n    // Modal.ui\n    render portal("Modal"); // this is where our Button element actually renders.\n    // we are able to use the button in the binding scope of our template but it is somewhere completely different in the hierarchy\n    // important! this also means that it will be laid out and styled as though it\'s parent were the parent of the portal,\n    // it is completely disconnected from its original usage except for bindings!\n\n}\n\n\n\n// Decorators are ways to inject behavior into elements that already defined. Example use cases might be we want to track some analytics\n// to see how often certain UIs are being used, or we want certain actions to trigger a route state change, or we need a way to\n// add tooltips to elements without refactoring the elements to be tooltip aware.\ntemplate DecoratorExample : DecoratorExample() {\n\n    // lets turn this button into something that is able to switch between menu screens. \n    // We could add a click handler here that does this logic, but it would be better if we \n    // could hook into a menu transition system that we previously created.\n    Button("Take me there!");\n\n    // using a decorator (which can be user defined) we add functionality that intercepts the button click\n    // and invokes our route transition instead. We didn\'t even alter the button to do this\n    @RouterLink("/game/main_menu")\n    Button("Take me there!");\n\n    // Decorators can also accept arbitrary bindings. In this case I extended the Button to also track how many times it was clicked,\n    // And setup an analytics category with an identifier. Button itself didn\'t change at all\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n\n    // We can combine as many decorators as we like. Here is the button with both analytics and routing attached\n    @RouterLink("/game/main_menu")\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n\n}\n\n// Containers are like templates but without the template\n// You can provide default handlers, decorators and binding values\n// and even require it to have children, not to have children, or only allow children\n// of a certain type. Containers may only appear at the top level in a .ui file\n// and cannot be defined inside of a template or function body\ncontainer Container : CompilerTest.ContainerElement(\nstyle = [@container-test],\nmouse:click = () => Debug.Log("Clicked Container"),\nattr:container = "true"\n);\n\n// an untyped container implictly extends `UIDefaultUntypedContainer` and can still accept\n// styling, attributes, input handlers, and decorators but no bindings (because the backing\n// type doesn\'t have any fields or methods to bind to).\ncontainer UntypedContainer(\nstyle = [@untyped]\n);\n\n// You can make containers generic if you like. The type `T` in this case will be in scope\n// for any bindings on the container but not for any of its children. Here we use a generic\n// where the backing class ignores the generic type\ncontainer GenericContainer<T>(\nattr:typeName = typeof(T)\n);\n\n\n// This time we use a backing type that happens to be generic, but the type is not\n// the type of our container, which is totally fine.\ncontainer GenericContainerMismatch<T> : CompilerTest.GenericContainer<string> (\nattr:typeName = typeof(T)\n);\n\n// This time we use a backing type that happens to be generic, this time the container\n// generic and the backing class generic match, whatever type you pass into the\n// container will be used to instantiate the backing type\ncontainer GenericContainerMatch<T> : CompilerTest.GenericContainer<T> (\nattr:typeName = typeof(T)\n);\n\n// any decorators you put on the container definition will be implicitly carried to their call sites too\n@ClickTracker("Group1", category = "Category")\ncontainer AnnotatedContainer();\n\n// Using containers is just like using other elements, they accept bindings, styles, attributes\n// etc and can have children or not.\nUntypedContainer(style = [@untyped]);\nGenericContainerMismatch<string>();\nGenericContainerMatch<float3>();\nGenericContainer<string>();\nGenericContainer<int>();\n\nAnnotatedContainer(); // implicitly carries the @ClickTracker decorator here\n\n// Containers can also extrude their values just like all other elements\nGenericContainerMatch<float>() [$element, value] {\nText("Value is: " + value);\nText("Element Type" + $element.GetType());\nrun value++; // the extrusions are by reference too, like normal\n}\n\nContainer(attr:container = "override", mouse:click = () => Debug.Log("Clicked")) {\nText("In a container");\n}\n\n// typography can also be defined in the same way as containers by using the `typography` keyword\n// it behaves identically to `container` except cannot accept a backing class, has no children, and\n// behaves identically to a Text() element. This lets you define various typography elements without\n// always passing styles to them\ntypography Label()\n\n// String interpolation works in the template language just like in C#\n// If you add a $ before the quote in a string, any expressions within { } are evaluated\n// This works anywhere strings are accepted, not just text elements\nText("Hello {19 + 51}"); // prints "Hello {19 + 51}"\nText($"Hello {19 + 51}"); // prints "Hello 70"\n\n// Markers are how we can navigate element hierarchies.\n// they are defined in templates via the `marker` keyword and\n// they accept an identifier as a name.\n// once defined they can be passed around, but they do not become\n// valid until after their block ends\nmarker x {\n// x not accessible here\nText("marker element 0");\nDiv() { // 1\nText("marker element 2");\nText("marker element 3");\nText("marker element 4");\nText("marker element 5");\n}\nText("Third marker element 6");\nDiv() { // 7\nDiv() { // 8\nText("marker element 9");\n}\n}\n}\n\n// outside the marker block, x follows all the regular scoping rules.\nrun PrintMarker(x);\n\n// once you have a marker it gives you access to all the elements within it via enumerators\n// note: this in C#, not in the template language but you could do the same thing in the template via a run block\npublic void PrintMarker(HierarchyMarker marker) {\n\n    UIElement parent = marker.GetParent();\n    UIElement firstMarkedElement = marker.GetFirstElement();\n    int elementCount = marker.ElementCount; // 10\n    bool hasElements = marker.HasElements; \n    bool isValue = marker.IsValid; // returns if the marker has elements and is still valid for the current frame\n\n    HierarchyMarker unscoped = marker.GetUnscoped(); // returns a new marker as though the parent element has been the only marked element\n\n    // create a marker as though `element` had been the only marked element\n    // only valid during the binding run, and must be called after the target \n    // element has been visited by the binding pass. \n\n    HierarchyMarker fromElement = HierarchyMarker.FromElement(someInstance); \n\n    // enumerate all top level elements => 0, 1, 6, 7\n    foreach (UIElement element in marker.GetSiblingEnumerator()) {\n        Debug.Log("Sibling: " + element);\n    }\n\n    // enumerate all elements regardless of hierarchy position \n    foreach (UIElement element in marker.GetEnumerator()) {\n        Debug.Log("Element: " + element);\n    }\n\n    // enumerates up the tree, will not return anything inside the { } block, rather the ancestors\n    foreach (UIElement parent in marker.GetAncestorEnumerator()) {\n        Debug.Log("Ancestor: " + parent);\n    }\n\n    // skips the first level and returns the children. in this example => 2, 3, 4, 5, 8\n    foreach (UIElement child in marker.GetChildrenEnumerator()) {\n        Debug.Log("Child: " + child);\n    }\n    \n    // skips the first level and returns the descendents. in this example => 2, 3, 4, 5, 8, 9\n    foreach (UIElement descendent in marker.GetDescendentEnumerator()) {\n        Debug.Log("Descendent: " + descendent);\n    }\n\n}\n\n// Markers can be used for a lot more than just iteration however. They can also allow elements\n// to be moved around in the hierarchy.\n\nmarker m0 {\n// marker bindings run at the time they are encountered in the hierarchy, like normal\nText("Inside of a marker");\n}\n\n// but we can choose to draw them some where else via the render marker function\nDiv() {\nText("Somewhere else");\nrender marker(m0); // m0 renders here, not where it was defined!\n}\n\n// sometimes we aren\'t sure if something should be displayed or not. For this purpose we can use a deferred marker.\n\n// marker will run the bindings here and the elements touched will be enabled as usual\n// however if there is no render marker() call for this marker, these elements will not\n// be part of layout and will not be rendered at all!\nmarker:defer m1 {\nText("Maybe show me");\n}\n\n// we can decide later if we want to use it or not\n\nif(someCondition) {\nrender marker(m1);\n}\n\n// markers can only be rendered once. If a marker is rendered multliple times, the last one wins\nrender marker(m1);\nrender marker(m1);\nrender marker(m1);\n\n// markers are just variables, they can be passed around to functions too\nElement(markerField = m1); // this element might decide to render the marker m1\n\n// You can also explicitly hide/show markers\n$runtime.HideMarker(marker);\n$runtime.ShowMarker(marker);\n\n// elements can declare life cycle handles directly in templates as well as in C#\n// Like the template method, this handle accepts not arguments, but does in inject\n// and element reference via the `$this` symbol which you can optionally use.\nDiv(\non:enable = ()     { Debug.Log("Enabled " + $this); },\non:create = ()     { Debug.Log("Created " + $this); },\non:update = ()     { Debug.Log("Updated " + $this); },\non:postUpdate = () { Debug.Log("Post Updated " + $this); },\non:disable = ()    { Debug.Log("Disable " + $this); },\non:destroy = ()    { Debug.Log("Destroy " + $this); }\n);\n\n// similar to how we can extrude values in templates, expressions can also extrude values\n// note the difference though: there is a required -> arrow and we don\'t support the `as`\n// syntax within the extrusion identifier block. Also when nesting extrusion blocks\n// a semi colon is required at the end just like any other statement type.\nstate KeyFrameAnimation<Color> anim = new KeyFrameAnimation<Color>() -> [a] {\na.SetDuration(1000);\na.AddKeyFrame(0, Color.red);\na.AddKeyFrame(1000, Color.yellow);\n\n    curveAnim -> [c] {\n        c.Thing();\n        c.Thing();\n        c.Thing();\n        c.Thing();\n        c.Thing();\n    };\n\n};\n\n\n\nModules\n\n// The idea behind modules is that they are portable between projects. They packages templates, styles, and assets together\n// and serve as a basis for resolving imports within .ui files. Modules can have dependencies on other modules.\n\n// There are no visibility rules for elements, all template / element declarations are considered to be public.\n\n// If a module (A) includes a dependency on another module (B) and (B) declares a dependency on (C), and (A) wants to\n// reference something in (C), (A) must declare a dependency on (C), it does NOT automatically inherit (B)\'s dependency on (C)\n\n// Modules are file system scoped and cannot be nested. A template & style file belong to the nearest module at the same level\n// or above them in the file tree. If no module asset exists in the project, it is an error.\n\n// some file.ui\n\nimport "SomeModuleName";\nimport "OtherModule" as Lib; // import \'OtherModule\' and alias it as \'Lib\'\n\n// A Module (which is an asset in Unity) can define a list of \'implicit\' imports\n// and these function as though the user had written `import "SomeModule"` in every file belonging to that module\n\ntemplate Something {\n\n    // the scope resolution operator is used to reference elements residing in imported modules\n    SomeModuleName::Button();\n\n    Lib::Button(); // using the alias \n    OtherModule::Button(); // using the full name, same result as the line above\n\n    Button(); // if no scope resolution operator is present, resolution is as follows\n              // 1. If the \'current\' module in which this file is defined defines \n              //    a template called \'Button\', then we us it. \n              // 2. If the current module does not define \'Button\', we look all the \n              //    imported modules declared in this file and search for \'Button\'. \n              //    If one is found, we use it. If multiple imported modules define\n              //    \'Button\', we throw an Ambiguous import error and the user is required\n              //    to use the :: operator to specify which version of \'Button\' to use\n\n}\n')))}m.isMDXComponent=!0}}]);