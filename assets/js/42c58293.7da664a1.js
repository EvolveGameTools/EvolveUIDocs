"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[51221],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},811:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(87462),r=(n(67294),n(3905));const i={toc:[{value:"Drag Event Types",id:"drag-event-types",level:3}]};function o(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"drag-event-types"},"Drag Event Types"),(0,r.kt)("p",null,"Drag create is a special snowflake because it accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"MouseInputEvent")," and expects to return an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"DragEvent"),".\nAll other drag handlers conform to the same signature requirements. If you omit a drag event type (listed as ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," in the table below),\nthen these events will fire any drag event type."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Mapping Method Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:create")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent")," OnDragCreate(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent)"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag could begin. Returning null will not start a drag. Returning any other subclass of ",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent")," will being a drag.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:move<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragMove(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," moves across this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:hover<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragHover(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," hovers over this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:update<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragUpdate(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," moves or hovers over this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:enter<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragEnter(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," enters this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:exit<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragExit(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," exits this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:drop<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragDrop(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drop event of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," occurs on this element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"drag:cancel<T>")),(0,r.kt)("td",{parentName:"tr",align:null},"OnDragCancel(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/DragEvent"},"DragEvent"),")"),(0,r.kt)("td",{parentName:"tr",align:null},"Fires when a drag event of type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," is canceled on this element")))))}o.isMDXComponent=!0},97500:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(87462),r=(n(67294),n(3905));const i={toc:[]};function o(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Mapping Method Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"focus:gain")),(0,r.kt)("td",{parentName:"tr",align:null},"OnFocusGained(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/FocusChangeEvent"},"FocusChangeEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"focus:lost")),(0,r.kt)("td",{parentName:"tr",align:null},"OnFocusLost(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/FocusChangeEvent"},"FocusChangeEvent"),")")))))}o.isMDXComponent=!0},35339:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(87462),r=(n(67294),n(3905));const i={toc:[]};function o(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Mapping Method Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key:down")),(0,r.kt)("td",{parentName:"tr",align:null},"OnKeyDown(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/KeyboardInputEvent"},"KeyboardInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key:heldDown")),(0,r.kt)("td",{parentName:"tr",align:null},"OnKeyHeldDown(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/KeyboardInputEvent"},"KeyboardInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"key:up")),(0,r.kt)("td",{parentName:"tr",align:null},"OnKeyUp(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/KeyboardInputEvent"},"KeyboardInputEvent"),")")))))}o.isMDXComponent=!0},8136:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(87462),r=(n(67294),n(3905));const i={toc:[]};function o(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Method Mapping Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:enter")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseEnter(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:exit")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseExit(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:up")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseUp(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:down")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseDown(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:heldDown")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseHeldDown(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:move")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseMove(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:hover")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseHover(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:context")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseContext(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:scroll")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseScroll(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:click")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseClick(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mouse:update")),(0,r.kt)("td",{parentName:"tr",align:null},"OnMouseUpdate(",(0,r.kt)("a",{parentName:"td",href:"/docs/api_generated/uncategorized_generated/MouseInputEvent"},"MouseInputEvent"),")")))))}o.isMDXComponent=!0},8899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>k,frontMatter:()=>p,metadata:()=>m,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),i=n(97500),o=n(811),l=n(35339),s=n(8136);const p={},d="Template Syntax",m={unversionedId:"templates/template_syntax",id:"templates/template_syntax",title:"Template Syntax",description:"EvolveUI has a very sophisticated template engine that takes in .ui",source:"@site/docs/templates/template_syntax.md",sourceDirName:"templates",slug:"/templates/template_syntax",permalink:"/EvolveUIDocs/docs/templates/template_syntax",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"conceptual",previous:{title:"Template Reflection",permalink:"/EvolveUIDocs/docs/templates/template_reflection"},next:{title:"Color Cheatsheet",permalink:"/EvolveUIDocs/docs/styles/colors"}},u={},c=[{value:"Exploring Template Syntax",id:"exploring-template-syntax",level:2},{value:"Data Binding",id:"data-binding",level:2},{value:"Template Syntax",id:"template-syntax-1",level:2},{value:"Companion types",id:"companion-types",level:3},{value:"Companion Input Events",id:"companion-input-events",level:4},{value:"Companion Lifecycle Attributes",id:"companion-lifecycle-attributes",level:4},{value:"Parameters",id:"parameters",level:3},{value:"Top level state",id:"top-level-state",level:3},{value:"Computed Properties",id:"computed-properties",level:3},{value:"Methods",id:"methods",level:3},{value:"Extrusion",id:"extrusion",level:3},{value:"Decorators",id:"decorators",level:3},{value:"Decorators",id:"decorators-1",level:2},{value:"Functional Syntax",id:"functional-syntax",level:2},{value:"Modules",id:"modules",level:2},{value:"Companion Types",id:"companion-types-1",level:3},{value:"Mapping values from companions",id:"mapping-values-from-companions",level:2},{value:"Mapping event and life cycle handlers from companions",id:"mapping-event-and-life-cycle-handlers-from-companions",level:2},{value:"Mouse Event Types",id:"mouse-event-types",level:3},{value:"Keyboard Event Types",id:"keyboard-event-types",level:3},{value:"Focus Event Types",id:"focus-event-types",level:3},{value:"Drag Event Types",id:"drag-event-types",level:3},{value:"Lifecycle of elements",id:"lifecycle-of-elements",level:3},{value:"Destructive Scopes",id:"destructive-scopes",level:4},{value:"Asynchronous Lifecycle",id:"asynchronous-lifecycle",level:4},{value:"Element References",id:"element-references",level:3},{value:"Template &amp; Typography &amp; Decorator declarations",id:"template--typography--decorator-declarations",level:5},{value:"Element references with companion types",id:"element-references-with-companion-types",level:4}],h={toc:c};function k(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"template-syntax"},"Template Syntax"),(0,r.kt)("p",null,"EvolveUI has a very sophisticated template engine that takes in ",(0,r.kt)("inlineCode",{parentName:"p"},".ui"),"\ntemplate syntax and converts it to IL code that is executed.\nThere are two ways this can happen, either at application start up time\nor as a build step. When running in dynamic mode, all the templates are\nparsed and MSIL is generated for them (assuming there weren't any\ncompilation errors)"),(0,r.kt)("p",null,"When pre-compiling we generate real C# code. This means we can fully support any AOT platforms and even run in Unity's il2cpp mode."),(0,r.kt)("p",null,"Performance between these two modes should be relatively similar,\nthough pre-compiling runs a bit faster as it's better at devirtualizing functions,\nperforms more inlining and will allocate less dynamic memory at runtime.\nTypically in development you would use dynamic mode because it allows you to\nhot-reload the entire UI when you change a template or style file. The\nexception to this rule is debugging. If you run into an issue with your\ntemplates that you'd like to debug, it may be easier to generate the\ncode and then set a breakpoint in the generated code."),(0,r.kt)("p",null,"Ok, on to the fun stuff!"),(0,r.kt)("h2",{id:"exploring-template-syntax"},"Exploring Template Syntax"),(0,r.kt)("p",null,"A template is defined in a ",(0,r.kt)("inlineCode",{parentName:"p"},".ui")," file and describes the structure of a UI and provides a super easy\nmethod to handle data binding between your UI hierarchy and your logic."),(0,r.kt)("h2",{id:"data-binding"},"Data Binding"),(0,r.kt)("p",null,"Any field, property, method, event, or value you use in data binding\nexpressions will need to be public. The reason for this is that when the\ncode is pre-compiled to C#, it will not compile if you use non\naccessible values."),(0,r.kt)("p",null,"In general you want to keep the data flow of\nyour UI in a top down direction. There are use cases for two way binding\non some elements like ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Dropdown")," but in general you should\nstrive to pass data down to children and not up to parents."),(0,r.kt)("h2",{id:"template-syntax-1"},"Template Syntax"),(0,r.kt)("p",null,"Templates can be defined syntactically with a functional notation or a long form structured notation. We'll focus on the structure notation for now.\nThroughout these examples we'll be building a totally fictional inventory system UI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Csharp"},'template Inventory {\n\n}\n\ntemplate Inventory {\n    \n    // inside of a template there is a \'render\' block that is used to render other UI elements\n    // We\'ll start simple and just render a static piece of text\n    render {\n        Text("My Inventory");\n        Text("I have lots of items");\n    }\n}\n\ntemplate Inventory {\n    \n    // we define a piece of state local to this instance of our UI element to track how many items are in our inventory\n    // state is defined with a \'state\' keyword \n    state int itemCount;\n    \n    render {\n        Text("My Inventory");\n        Text($"I have {itemCount} items");\n    }\n}\n\n\n')),(0,r.kt)("h3",{id:"companion-types"},"Companion types"),(0,r.kt)("p",null,"A companion is a C# type that supports integration with a ui template. It can be a struct or a class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"\n// in a C# file somewhere\npublic struct InventoryCompanion {\n\n    // any public fields, methods, properties, or events are visible to ui templates\n    public float someField;\n    \n    // defining a field of type ElementReference and adding an [InjectElementReference] attribute will automatically\n    // link this field to the ui element of the template this companion is bound to\n    [InjectElementReference]\n    public ElementReference elementRef;\n    \n    // [InjectUIRuntime] will automatically set this fields value to the UI runtime to which the bound template belongs\n    [InjectUIRuntime]\n    public UIRuntime runtime;\n    \n    public int ComputeItemCount() { ... }\n    \n    // any event handler method can be marked with an attribute to implicitly register itself as a handler for the \n    // corresponding event type. The method must conform to the given event handler signature, in this case accepting either \n    // a single MouseEvent parameter or no parameters. The method names do not matter, only the signature and the attributes.\n    [OnMouseDown]\n    public void OnMouseDown(MouseEvent evt) {\n        ...\n    }\n    \n    [OnMouseUp] // The MouseEvent parameter can be omitted if it is not used\n    public void HandleMouseUp() {\n        ...\n    }\n    \n    // Similar to input event handlers, life cycle events can also be declared on a companion type with attributes\n    // life cycle handlers do not accept any parameters, and can declare any return type they like (which is ignored by the template system anyway)\n    [OnUpdate]\n    public void Update() {\n        ...\n    }\n    \n}\n\n\n// in a .ui file\n\n// a companion is defined with the ':' operator and the name of the C# type which will serve as the companion\ntemplate Inventory : InventoryCompanion {\n\n    render {\n        // anywhere inside of a template declaration, '$companion' will provide the companion instance.\n        // any public field, property, method, or event can then by accessed from that instance.\n        Text($\"Inventory has {$companion.ComputeItemCount()} items\");\n    }   \n    \n}\n\n")),(0,r.kt)("h4",{id:"companion-input-events"},"Companion Input Events"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseDown")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseUp")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseClick")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseHelDown")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseEnter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseExit")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseContext")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseMove")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnMouseHover")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnKeyDown")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnKeyHeldDown")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnKeyUp")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnTextInput")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDragCreate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDragMove")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDragCancel")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDragDrop")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDragFinish"))),(0,r.kt)("h4",{id:"companion-lifecycle-attributes"},"Companion Lifecycle Attributes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnCreate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnEnable")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnUpdate")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnFinish")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDisable")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnDestroy"))),(0,r.kt)("h3",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"Templates can accept parameters which is the preferred way to get data into them. Parameters can be either declared\ndirectly in a template or using a ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," declaration. They can optionally define a default value. If a default value\nis not provided, then the user must pass in a value for that parameter or the compiler will emit an error."),(0,r.kt)("p",null,"There are two types of parameter declarations: ",(0,r.kt)("inlineCode",{parentName:"p"},"required")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"optional"),". Required parameters cannot define a\ndefault value, but optional parameters can."),(0,r.kt)("p",null,"Parameters can either define a new field on a template or use a feature called ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," to alias another expression."),(0,r.kt)("p",null,"Required parameters must be defined before optional ones. The order in which you define your parameters is also\nthe order in which a caller must provide them if not explicitly referring to them by name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"template ParameterExample {\n\n    required Vector3 vec; // define a required parameter \n    optional float value; // define an optional parameter\n    optional string name = \"EvolveUI\"; // define an optional parameter with a default value\n    \n    optional float valueX from stateVector.x; // map this parameter to stateVector's x field \n    optional float valueY from stateVector.y = 3.14159f; // map this parameter to stateVector's y field, with a default value\n    state Vector3 stateVector;\n    \n    // private parameters are not visible outside of the template definition. A caller can still pass them \n    // into the template but they cannot be used with the `sync` or `onChange` declarations and cannot be extruded\n    optional:private string secret;\n    \n}\n\ntemplate ParameterUsage {\n\n    render {\n        ParameterExample(vec = new Vector3(), valueX = 10, valueY = 11);\n    }\n    \n}\n\n")),(0,r.kt)("h3",{id:"top-level-state"},"Top level state"),(0,r.kt)("p",null,"Top level state is accessible everywhere inside of a template. State is public by default which means\nthat when a template is used, public state can be extruded. When using the ",(0,r.kt)("inlineCode",{parentName:"p"},":private")," visiblity modifier\nstate fields cannot be extruded."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Csharp"},"template StatefulExample : CompanionType {\n\n    state float value; // define template-local state field \n    \n    state float valueWithDefault = 100f;\n    \n    state:private string privateState = \"Not visible outside of this template\";\n    \n    // top level state can also be mapped to a companion field \n    state string itemName from $companion; // if no field/property name is provided, it assumes you want the 'itemName' field/property from the companion\n    state string itemRarity from $companion.rarity; // if a field/property name is provided, that will be used\n\n    // you can both map a companion field and provide a default value like this:\n    state int itemValue from $companion = 100;\n        \n}\n")),(0,r.kt)("h3",{id:"computed-properties"},"Computed Properties"),(0,r.kt)("p",null,"A computed property is a read only method which can be extruded like a value. Computed properties are public\nby default but can be annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},":private")," to make them only visible inside the defining template. They\ncannot be used with a ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," mapping but do have access to any top level field declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'template ComputedPropertyExample {\n    \n    state int x;\n    state int y;\n    \n    computed int sum => x + y;\n    \n    // only visible inside this template\'s definition\n    computed:private int product => x + y;\n    \n}\n\ntemplate UsingAComputedProperty render {\n    \n    // a computed property can be extruded with the [] operator\n    ComputedPropertyExample() [sum]\n    \n    Text($"x + y is {sum}");\n    \n}\n\n')),(0,r.kt)("h3",{id:"methods"},"Methods"),(0,r.kt)("p",null,"Methods can be defined with any signature you like. By default they are public and can be extruded.\nMethods are available within other methods as well, and can be sourced with a\n",(0,r.kt)("inlineCode",{parentName:"p"},"from")," mapping or defined in the template definition itself."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"\ntemplate MethodExample : SomeCompanionType {\n    \n    // when defining a method from a companion type you must define the signature explicitly\n    // and it must exactly match the method as it was defined in the companion type\n    method float Sqrt(float input) from $companion;\n    \n    method float PrintSqrt(float input) {\n        // using the Sqrt method\n        Debug.Log(Sqrt(input));\n    }\n    \n    method void PrintValue(int value) {\n        Debug.Log(value);\n    }\n    \n}\n\ntemplate MethodUsage render {\n\n    // methods get extruded like normal with the [] operator\n    MethodExample() [PrintValue, PrintSqrt];\n    \n    run PrintValue(100);\n    run PrintValue(200);\n    run PrintSqrt(300f);\n    \n}\n\n")),(0,r.kt)("h3",{id:"extrusion"},"Extrusion"),(0,r.kt)("p",null,"Where parameters are the way to get data into a template, extrusions are the way to get data back out. You can think of\nextrusion the same way you think about deconstruction in some languages."),(0,r.kt)("p",null,"Any public ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"required"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"optional"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"computed"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"method")," can be extruded, along with a reference to a template's UI element."),(0,r.kt)("p",null,"Extrusion is performed using the ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," operator, which accepts a list of expressions to extrude."),(0,r.kt)("p",null,"template ExtrusionExample render {"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ThingWithInternalState() [value1, value2] {\n    run Debug.Log(value2);\n}\n// extrusion scope is not constrained to the child scope created with `{}`\nrun Debug.Log(value1); \n\n// sometimes there may be naming conflicts with extruded values. When this is the case, you can \n// an assign an alias to the extruded value with the 'as' operator\n\nstate float xyz;\nSomeElement() [xyz as abc]; // alias SomeElement.xyz as abc because xyz was already defined in this scope\n\n// an element reference is extruded with the '&' operator and any unique identifier that is valid in the scope\nSomeElement() [&elementRef] \nrun Debug.Log(elementRef.GetAttribute(\"selected\"));\n")),(0,r.kt)("p",null,"}"),(0,r.kt)("h3",{id:"decorators"},"Decorators"),(0,r.kt)("h2",{id:"decorators-1"},"Decorators"),(0,r.kt)("p",null,"Decorators are ways to inject behavior into elements that are already defined. An example use case might be that we want to track some analytics\nto see how often certain UIs are being used, or we want certain actions to trigger a route state change, or we need a way to\nadd tooltips to elements without refactoring the elements to be tooltip aware."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'template DecoratorExample render {\n\n    // lets turn this button into something that is able to switch between menu screens. \n    // We could add a click handler here that does this logic, but it would be better if we \n    // could hook into a menu transition system that we previously created.\n    Button("Take me there!");\n\n    // using a decorator (which can be user defined) we add functionality that intercepts the button click\n    // and invokes our route transition instead. We didn\'t even alter the button to do this\n    @RouterLink("/game/main_menu")\n    Button("Take me there!");\n\n    // Decorators can also accept arbitrary bindings. In this case I extended the Button to also track how many times it was clicked,\n    // And setup an analytics category with an identifier. Button itself didn\'t change at all\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n\n    // We can combine as many decorators as we like. Here is the button with both analytics and routing attached\n    @RouterLink("/game/main_menu")\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu")\n    Button("Take me there!");\n    \n    // decorators can also work with extrusion the same way templates do\n    @TrackClicks(category = "Transitions", identifier = "Go To Main Menu") [totalClicks]\n    Button("Clicked: " + totalClicks + " times");\n\n}\n\n// you can also define decorators on template and typography declarations, which has the same effect as placing them at the usage site\n// like we did in the above examples. Decorators used this way can accept values computed from the template\'s state and parameters\n// and can extrude values that are usable within the template definition.\n@RouterLink("Game/Inventory")\n@SomeDecorator(value = someValue) [extrudedThing]\ntemplate TopLevelDecoratorExample { \n\n    optional int someValue;\n    computed int computeMe => someValue * extrudedThing;\n    \n    // ...contents...\n}\n')),(0,r.kt)("p",null,"Decorators are defined in a similar manner to templates. They can declare state, params, computed properties, methods, styles, attributes and a companion type.\nThey can also define input and life cycle handlers. Unlike a template, decorators cannot declare a render block, and cannot themselves be decorated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'decorator MyDecorator {\n    \n    required string name;\n    \n    style:BackgroundColor = Color.red;\n    \n    style = [@one, @two];\n    \n    method string GetName() {\n        return $"Hello, my name is {name}";\n    }\n    \n}\n\ndecorator DecoratorWithCompanion : CompanionType {\n    \n    state int frameCount = 0;\n    \n    state string value from $companion;\n    \n    attr:someAttribute = value;\n    \n    before:update => frameCount++;\n    \n    mouse:down => $companion.HandleMouse($evt);\n    \n}\n\n')),(0,r.kt)("h2",{id:"functional-syntax"},"Functional Syntax"),(0,r.kt)("p",null,"Sometimes its annoying to type a full template definition for a template that doesn't declare much."),(0,r.kt)("p",null,"You can use the template shorthand for these cases which is functionally identical to the long form\ndeclaration, but instead of using a block to declare all of the members, you declare a list of statements like a function signature\nand use the ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," keyword followed by a block to define the contents."),(0,r.kt)("p",null,"This functional syntax works for ",(0,r.kt)("inlineCode",{parentName:"p"},"template"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"typography"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," but not ",(0,r.kt)("inlineCode",{parentName:"p"},"decorator"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'\ntemplate Greeter(param string name) render {\n    Text($"Hello {name}");    \n}\n\n')),(0,r.kt)("h2",{id:"modules"},"Modules"),(0,r.kt)("p",null,"The idea behind modules is that they are portable between projects. They packages templates, styles, and assets together\nand serve as a basis for resolving imports within .ui files. Modules can have dependencies on other modules."),(0,r.kt)("p",null,"There are no visibility rules for elements, all template / element declarations are considered to be public."),(0,r.kt)("p",null,"If a module (A) includes a dependency on another module (B) and (B) declares a dependency on (C), and (A) wants to\nreference something in (C), (A) must declare a dependency on (C), it does NOT automatically inherit (B)'s dependency on (C)"),(0,r.kt)("p",null,"Modules are file system scoped and cannot be nested. A template & style file belong to the nearest module at the same level\nor above them in the file tree. If no module asset exists in the project, it is an error."),(0,r.kt)("p",null,"When resolving names for templates & styles, the module in which the template or style is being used is first searched.\nIf there is a template or style that is found, then it is used. If we didn't find the target in the local module, then\nall of the auto imports and explicit imports are searched. If there is only one match then it is taken. If multiple matches\noccur then an error is shown and you need to explicitly disambiguate using a ",(0,r.kt)("inlineCode",{parentName:"p"},"ModuleAlias::YourThing")," fully qualified identifier."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// some file.ui\n\nimport SomeModuleName;\nimport OtherModule as Lib; // import 'OtherModule' and alias it as 'Lib'\n\n// A Module (which is an asset in Unity) can define a list of auto imports\n// and these function as though the user had written `import SomeModule` \n// in every file belonging to that module\n\ntemplate Something render {\n\n    // the scope resolution operator is used to reference elements residing in imported modules\n    SomeModuleName::Button();\n\n    Lib::Button(); // using the alias \n    OtherModule::Button(); // using the full name, same result as the line above\n\n    Button(); // if no scope resolution operator is present, resolution is as follows\n              // 1. If the 'current' module in which this file is defined defines \n              //    a template called 'Button', then we us it. \n              // 2. If the current module does not define 'Button', we look all the \n              //    imported modules declared in this file and search for 'Button'. \n              //    If one is found, we use it. If multiple imported modules define\n              //    'Button', we throw an Ambiguous import error and the user is required\n              //    to use the :: operator to specify which version of 'Button' to use\n\n}\n")),(0,r.kt)("h3",{id:"companion-types-1"},"Companion Types"),(0,r.kt)("p",null,"A companion is any type that is declared in C# that is bound to your ",(0,r.kt)("inlineCode",{parentName:"p"},"template"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"typography"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"decorator"),"\ndeclaration. The purpose of a companion is to provide a generic way to integrate C# code with a template."),(0,r.kt)("p",null,"A type is valid as a companion as long as it is public and defines a parameterless constructor or is a struct."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// C# type somewhere in your project\n\npublic struct SomeCompanion {\n    \n    public int hitPoints;\n    \n    public string currentLevelName;\n    \n    public void ReloadWeapon() {\n        // assume this does work in your game\n    }\n    \n}\n\n// ... some template file ...\n\n// : typeName syntax declares a companion type binding for this template\n// there can only be 1 companion per template. When declaring a companion type,\n// a new built-in variable becomes available in the template: $companion. \n// this refers to the companion instance for this template. From this reference\n// you can use any public field, method, property, or event that the type exposes. \ntemplate ThingWithCompanion : SomeCompanion {\n\n    render {\n    \n        Text($"Current Level is {$companion.currentLevelName}")\n        \n        HealthBar($companion.hitPoints);\n        \n        // you can call methods exposed on the companion instance\n        Button("Reload", mouse:click => $companion.ReloadWeapon());\n        \n    }\n    \n}\n\n')),(0,r.kt)("h2",{id:"mapping-values-from-companions"},"Mapping values from companions"),(0,r.kt)("p",null,"You can map values from a companion in the same way you could map them from ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// c# file \npublic class Inventory {\n    \n    public int selectedItemIndex;\n    \n    public string[] GetItemNames() { ... }\n    \n    public string GetEquippedItemName(int itemIndex) { ... }\n    \n}\n\n// template file \ntemplate InventoryUI : Inventory {\n\n    // we alias the selectedItemIndex parameter from the selectedItemIndex field on the companion\n    required int selectedItemIndex from $companion.selectedItemIndex;\n    \n    // when mapping from a companion, if the companion's field name matches the template's declared name\n    // then you can omit the field name. This line is the same as the one above but shorter. \n    required int selectedItemIndex from $companion;\n    \n    method string[] GetItemNames() from $companion; // when mapping a method, the signatures must match exactly.\n    \n    // you can pick a different name for the template value if you specify the source explicitly;\n    method string GetItemName(int itemIndex) from $companion.GetEquippedItemName;\n}\n")),(0,r.kt)("h2",{id:"mapping-event-and-life-cycle-handlers-from-companions"},"Mapping event and life cycle handlers from companions"),(0,r.kt)("p",null,"An event or life cycle can also be mapped from the companion. As long as the signatures match\nbetween the event you are mapping and the method on the companion instance, the mapping is valid."),(0,r.kt)("p",null,"There is also a shorthand for mapping both input event names and life cycle handlers. For lifecycle events\nthe return type is ignored and can be anything as long as your mapping method defines no parameters. "),(0,r.kt)("p",null,"The name mapping table for lifecycle events is below:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Method Mapping Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:create")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeCreate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:create")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterCreate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:enable")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeEnable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:enable")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterEnable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:update")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeUpdate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:update")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterUpdate")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:input")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeInput")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:input")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterInput")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:finish")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeFinish")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:finish")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterFinish")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:disable")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeDisable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:disable")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterDisable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"before:destroy")),(0,r.kt)("td",{parentName:"tr",align:null},"OnBeforeDestroy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"after:destroy")),(0,r.kt)("td",{parentName:"tr",align:null},"OnAfterDestroy")))),(0,r.kt)("p",null,"There is a similar mapping table for input event names, however with the added caveat that signature of your method must also match"),(0,r.kt)("h3",{id:"mouse-event-types"},"Mouse Event Types"),(0,r.kt)(s.ZP,{mdxType:"MouseEventTable"}),(0,r.kt)("h3",{id:"keyboard-event-types"},"Keyboard Event Types"),(0,r.kt)(l.ZP,{mdxType:"KeyEventTable"}),(0,r.kt)("h3",{id:"focus-event-types"},"Focus Event Types"),(0,r.kt)(i.ZP,{mdxType:"FocusEventTable"}),(0,r.kt)("h3",{id:"drag-event-types"},"Drag Event Types"),(0,r.kt)(o.ZP,{mdxType:"DragEventTable"}),(0,r.kt)("h3",{id:"lifecycle-of-elements"},"Lifecycle of elements"),(0,r.kt)("p",null,"Evolve's template system works on a concept called ",(0,r.kt)("inlineCode",{parentName:"p"},"Structural Identity"),". This means that the compiler\nfigures out which 'scope' and element belongs to and ties that element's lifecycle to the scope. Scopes\nare created whenever there control flow and all elements declared in that scope are bound to its lifecycle."),(0,r.kt)("p",null,"This means we only create elements when we enter a scope for the first time and we disable or destroy elements\nwhen the scope is no longer in use. Every frame as your template execute the system figures out if the control flow\nbeing run was also run last frame or not and decides if it needs to create the elements within this scope or if\nit should use the same instances from last frame. One of the great things about system is that you can declare\n",(0,r.kt)("inlineCode",{parentName:"p"},"state")," variables anywhere inside of a scope and they will retain their values across frames. "),(0,r.kt)("p",null,"Here is how a frame is built for each template in your game. "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Was this the first time this scope was entered?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,r.kt)("inlineCode",{parentName:"li"},"created")," hooks that are defined on the elements"))),(0,r.kt)("li",{parentName:"ul"},"Was this created this frame or previously disabled?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if so then invoke any ",(0,r.kt)("inlineCode",{parentName:"li"},"enabled")," hooks"))),(0,r.kt)("li",{parentName:"ul"},"Set all of the per-frame 'bindings' for the currently executing element. This includes:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"parameters"),(0,r.kt)("li",{parentName:"ul"},"non constant styles"),(0,r.kt)("li",{parentName:"ul"},"non constant attributes"))),(0,r.kt)("li",{parentName:"ul"},"invoke any before early input hooks"),(0,r.kt)("li",{parentName:"ul"},"process input"),(0,r.kt)("li",{parentName:"ul"},"invoke any after early input hooks"),(0,r.kt)("li",{parentName:"ul"},"invoke any update hooks"),(0,r.kt)("li",{parentName:"ul"},"invoke any after update input hooks"),(0,r.kt)("li",{parentName:"ul"},"recursively visit all of the children of this template"),(0,r.kt)("li",{parentName:"ul"},"invoke any late input hooks "),(0,r.kt)("li",{parentName:"ul"},"invoke any finish hooks")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'template Example(required bool showGroup1) render {\n    if(showGroup1) {\n        // a new scope is created for the true case \n        // the two text elements below are bound to this scope\n        // if this branch does not execute in a given frame, \n        // all elements that are descendents of this scope will be\n        // disabled (or destroyed if the scope is marked with :destructive)\n        Text("Element 1");\n        Text("Element 2");\n    }\n    else {\n        // a new scope is created for the else case \n        // Element 3 is a member of this scope.\n        Text("Element 3");\n    }\n}\n')),(0,r.kt)("h4",{id:"destructive-scopes"},"Destructive Scopes"),(0,r.kt)("p",null,"A scope can be marked as destructive using a ",(0,r.kt)("inlineCode",{parentName:"p"},":destructive")," tag after its declaration. Some examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"if:destructive()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"else:destructive")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"else if:destructive")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"switch:destructive() { .. }")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'case:destructive "condition" { .. }')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default:destructive { .. }"))),(0,r.kt)("p",null,"Some scopes are implicitly destructive, such as those generated by a ",(0,r.kt)("inlineCode",{parentName:"p"},"repeat"),". In the\ncase of ",(0,r.kt)("inlineCode",{parentName:"p"},"repeat"),", if the input size shrinks from one frame to another then the extra\nitems that were inside the repeat last frame will be destroyed. If a repeat is disabled due\nto its parent scope being disabled, its child scopes will be disabled as normal and not be destroyed."),(0,r.kt)("p",null,"Destroying a ",(0,r.kt)("inlineCode",{parentName:"p"},"View")," will destroy all of its descendent scopes and their associated elements. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'template Example(required bool showGroup1) render {\n    // because this scope is marked as destructive, if there is a frame in which\n    // this branch is not entered, its descendents will all be destroyed instead of\n    // being disabled as they normally would be. When the branch is later re-entered\n    // the elements we be re-created again.\n    if:destructive(showGroup1) {\n        Text("Element 1");\n        Text("Element 2");\n    }\n}\n')),(0,r.kt)("h4",{id:"asynchronous-lifecycle"},"Asynchronous Lifecycle"),(0,r.kt)("p",null,"There are two classes of events which are not executed as your code runs each frame: ",(0,r.kt)("inlineCode",{parentName:"p"},"disable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"destroy"),". "),(0,r.kt)("p",null,"For performance reasons we only run these handlers at the start of the next frame. It is illegal / undefined behavior\nif you have a disable/destroy handler that uses a closure to close over any fields / state in a template. Generally,\nyou should not have to worry about this because the system makes it very hard to do, but in case you are tempted to\ntrick the system into doing something crazy: you've been warned! "),(0,r.kt)("h3",{id:"element-references"},"Element References"),(0,r.kt)("p",null,"Evolve is a high performance UI library and as such makes certain decisions around what the concept of a UI element really is. Unlike\nmost other UI systems, the core unit of Evolve is not a tree node that is subclassed from some type, but a simple 4 byte type called ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementId"),". "),(0,r.kt)("p",null,"Because we don't use real objects to represent our UI elements, we need a way work with ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementId"),"s in the context of our game in order to\nset styles, attributes, perform layout and do all of the typical UI things. The solution to this in Evolve is a type called ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementReference"),". "),(0,r.kt)("p",null,"The purpose of an ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementReference")," is to be the one stop shop for interfacing with the system data for a single element. An ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementReference")," can be\nused to query layout results, set style properties, manipulate a list of applied styles, check the 'live-ness' of an element, and is often passed around\nin templates as arguments to things that need to position themselves relatively or query an element for certain properties. "),(0,r.kt)("p",null,"There are a few ways to get an ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementReference")," depending on the context you are working in. "),(0,r.kt)("h5",{id:"template--typography--decorator-declarations"},"Template & Typography & Decorator declarations"),(0,r.kt)("p",null,"When inside of a top level declarations (except for ",(0,r.kt)("inlineCode",{parentName:"p"},"function"),") you can always use ",(0,r.kt)("inlineCode",{parentName:"p"},"$element")," to get the current element reference.\nInside of a ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," block, ",(0,r.kt)("inlineCode",{parentName:"p"},"$element")," becomes contextual based on where it is used and is only valid inside a binding expression.\nIt is not valid inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"create"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"run"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"enable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"var"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"repeat"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," or any other expression that is not related to\nproperty or lifecycle binding.  "),(0,r.kt)("p",null,"In a given element usage like ",(0,r.kt)("inlineCode",{parentName:"p"},'Text("xyz")'),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"$element")," reference becomes available inside of bindings. "),(0,r.kt)("p",null,"When inside of a ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," block, you can refer to ",(0,r.kt)("inlineCode",{parentName:"p"},"$root")," to get an\nElementReference for the current template root, in the example below it would point at ",(0,r.kt)("inlineCode",{parentName:"p"},"Thing"),". "),(0,r.kt)("p",null,"You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"$parent")," to refer to an element's parent. This is available everywhere inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," block and always points to\nthe currently executing element's parent. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'template Thing {\n\n    before:update => {\n        $element.SetAttribute("ticked", true); // in a top level declaration $element points to Thing\n    }\n     \n    render {\n    \n        Text($"the element is {$element}"); // refers to the Text element\n        Text($"the element is {$root}"); // refers to the Thing, which is the template root\n        \n        run $element.SetAttribute("illegal", true); // $element points nowhere, this is not allowed\n        run $root.SetAttribute("illegal", false); // $root points to Thing, totally fine\n        \n        run $parent.SetAttribute("fine, "yep"); // $parent points at Thing\'s parent. this MAY be invalid if Thing is a view root and has no parent. \n        \n        Element1(value = $parent) { // $parent == Thing\n           Element2(value = $parent) { // $parent == Element1\n        }\n        \n    }\n}\n')),(0,r.kt)("p",null,"Inside of a decorator, ",(0,r.kt)("inlineCode",{parentName:"p"},"$element")," points to the element being decorated. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"decorator SomeDecorator {\n\n    before:update => $element.stlye.BackgroundColor = `red`;\n    \n}\n")),(0,r.kt)("h4",{id:"element-references-with-companion-types"},"Element references with companion types"),(0,r.kt)("p",null,"When defining a companion type in C#, you can define a public, non readonly field of type ",(0,r.kt)("inlineCode",{parentName:"p"},"ElementReference")," and mark it with the attribute ",(0,r.kt)("inlineCode",{parentName:"p"},"[InjectElementReference]"),"\nand the system will set the value of this field to the paired ElementReference. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// when used as a companion, the myElementReference will be set by the system. This still works even if this companion type\n// is used as a companion for a decorator. Note that it will NOT be set when used as the companion of a `function`, because functions\n// are not mapped 1-1 with elements. No error will be thrown in this case, the field will simply not be initialized. \npublic class SomeCompanion {\n\n    [InjectElementReference]\n    public ElementReference myElementReference;\n\n}\n\n")))}k.isMDXComponent=!0}}]);